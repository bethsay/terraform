We are starting a new project of managing iam users and their permissions/policies.
    #mkdir 02-aws-iam/

So far, our terraform.tfstate had been stored locally. This is fine if you are not collaborating for your terraform projects.
Terraform allows for the use of aws s3 buckets to maintain terraform state files with encryption, versioning, file locking and access control.
The bucket must have been created and be accessible before it can be configured and as a backend.
Also, No dynamic bucket names or variable resource mapping is supported within the terraform, required_providers, backend, or provider blocks.
Knowing this lets create a sub project to handle this s3 pre-requisite.
    #mkdir ./02-aws-iam/pre-init/ && cd ./02-aws-iam/pre-init/
Use the aws provider and set it up with shared config, creds, profile. https://registry.terraform.io/providers/hashicorp/aws/latest/docs#shared-configuration-and-credentials-files
    #vim providers.tf
We wont be using s3 backend config here, so, our terraform.tfstate will be local
Initialize the project by installing the provider plugin/binary
    #terraform init
Define variables for s3_prefix(string), bucket_force_destroy(bool), bucket_extra_tags(map) with default values
    #vim variables.tf
To ensure we get a unique bucket_name, lets use a local generate a uuidv5, split it, and use any part of it as bucket suffix.
Create an aws_s3_bucket resource using the variables and local as bucket, force_destroy, and tags argument.
Terraform recomends that the backend bucket must have versioning enabled. https://developer.hashicorp.com/terraform/language/backend/s3
Create aws_s3_bucket_versioning resource with versioning Enabled for aws_s3_bucket resource. 
    #vim backend.tf
Lets output the bucket name/id to be used later.
    #vim outputs.tf
Lets get these resources created.
    #terraform apply
    #aws s3api list-buckets
    #aws s3api get-bucket-versioning --bucket $(aws s3api list-buckets | jq -r '.Buckets[0].Name')
    #terraform output s3_id
    #aws s3api get-bucket-versioning --bucket $(terraform output -raw s3_id)
Everytime you stop working on this project or when you have completed this project, delete all resources
    #terraform destroy

Lets switch back to our main project
    #cd 02-aws-iam/
Use the aws provider and set it up with shared config, creds, profile.
    #vim providers.tf
Lets configure an s3 bucket as the backend. https://developer.hashicorp.com/terraform/language/backend/s3
To run terraform commands in other project directories, use the -chdir flag
Lets re-apply our pre-init sub project.
    #terraform -chdir=./pre-init apply
    #terraform -chdir=./pre-init output s3_id
Create backed s3 block with the bucket name from pre-init, any "path/state_file_name" as key, aws region of bucket, and lockfile toggle
    #vim providers.tf
If you are not using the default s3_prefix value to create a bucket
    #terraform -chdir=./pre-init apply -var 's3_prefix=custom-name'
    #terraform -chdir=./pre-init output s3_id
    #terraform -chdir=./pre-init output -raw s3_id | { read S3_ID; sed -i "s/\(bucket *= *\"\).*\(\"\)/\1$S3_ID\2/" providers.tf
    #sed -i "s/\(bucket *= *\"\).*\(\"\)/\1$(terraform -chdir=./pre-init output -raw s3_id)\2/" providers.tf
Or if you already have a bucket created with a different name, overwrite the backend bucket value
    #sed -i "s/\(bucket *= *\"\).*\(\"\)/\1$(echo "<external_bucket_name>")\2/" providers.tf
The need to excessively use backslash makes this sed hard to read.
The LHS of sed looks for "bucket+spaces( *)+equal(=)+spaces( *)+quotes(\")+any_char(.*)+quotes(\")" to replace.
The LHS of sed also creates 2 capture groups using brackets, ie, "\(...\) and \(...\)". 1st is (bucket *= *\") and 2nd is (\").
The RHS of sed writes "1st_capture(\1)+output_of_command($(echo "name")+2nd_capture(\2)"
This sed allows the command to work if terraform fmt is run or not. It also allows you to retain any comments on the same line.
Now that provider and backend has been configured, initialize the project.
    #terraform init

If at a later time you update the backend config to a different bucket or to a different backend type, terraform init must be re-run.
If modification is to migrate the state files of current project to a different backend,
    #terraform init -force-copy
The actual flag to use is -migrate-state, but it is implied when using the flag -force-copy
If you terraform destroy your entire project and the backend bucket, and later want to init with a different backend,
Or if you use the same code/project to manage resources in a different aws account/region with a different backend.
    #terraform init -reconfigure
This will wipe the state file and disconnect the current terraform project from all resources/modules of the previous project.

Lets create the first resource of our iam project
Using the aws_iam_user resource, create a user. name is a required argument. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_user
    #vim iam.tf
path argument is optional and does not affect how the user access is utilized.
Default path value is "/". path string must always start and end with "/".
Even if the path is different from an exisiting user, the name cannot be reused.
path argument is an attribute that allows to manage policies using a tree structure of iam_users and iam_groups.
Create the resources and check if the user have been created via console or cli
    #terraform apply
    #terraform state list
    #terraform state show aws_iam_user.first
    #aws iam list-users
    #aws iam get-user help
    #aws iam list-users | jq -r '.Users[].UserName' | xargs -L 1 aws iam get-user --user-name
Lets create output blocks to retrun the id and arn of the created user. arn is amazon resource name
    #vim outputs.tf
Lets also create variables for name, path, and force_destroy to be used in aws_iam_user resource
    #vim variables.tf
    #vim iam.tf
    #terraform apply
    #terraform state output
    #aws iam get-user --user-name $(terraform output -raw user_name)
If you are taking a break from working on iam project and want to cleanup, destroy the resources here and of pre-init
    #terraform destroy -auto-approve && terraform -chdir=./pre-init destroy -auto-approve

For the user to have programmatic access, they will need to generate an access key and its corresponding secret.
    #aws iam list-access-keys --user-name $(terraform output -raw user_name)
    #aws iam create-access-key --user-name $(terraform output -raw user_name)
    #aws iam list-access-keys --user-name $(terraform output -raw user_name)
    #aws iam delete-access-key --user-name $(terraform output -raw user_name) --access-key-id $(!-1 | jq -r '.AccessKeyMetadata[].AccessKeyId')
        ->"!-1" is a history substitution. Bash will replace it with the latest command from current sessions history.
        ->This delete-access-key command will fail if list-access-keys command was not the previous command.
Create bool variable for api_access which defaults to true.
    #vim variables.tf
    #terraform console
        #var.api_access
        #var.console_access
Create aws_iam_access_key resource with the aws_iam_user.first.id. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_access_key
Set its count as 1 if var.api_access is true, else count should be 0
    #vim iam.tf
    #terraform apply
    #terraform state show aws_iam_access_key.first[0]
    #aws iam list-access-keys help
    #aws iam list-access-keys --user-name $(terraform output -raw user_name)
    #terraform show -json | jq '.values.root_module.resources[] | select(.address=="aws_iam_access_key.first[0]") | .values'
    #terraform show -json | jq '.values.root_module.resources[] | select(.address=="aws_iam_access_key.first[0]") | .values | {access_key: .id, secret_key: .secret}'
Create output block to show id of aws_iam_access_key. Use one function to get the id of aws_iam_access_key if it exists.
To show secret of aws_iam_access_key in output block, the sensitive argument must be set to true. Use one function here as well.
    #vim output.tf
    #terraform apply
    #terraform output
    #terraform output api_access
    #terraform output api_secret
You can see that the sensitive output stays hidden after apply and output all but is shown when you specifically output it.

For the user to be able to login to aws console, We can generate a login_profile for them to use.
    #aws iam get-login-profile --user-name $(terraform output -raw user_name)
    #aws iam create-login-profile --user-name $(terraform output -raw user_name) --password <something>
        ->password must have uppercase and lowecase letters, numbers, symbols
    #aws iam get-login-profile --user-name $(terraform output -raw user_name)
    #aws iam delete-login-profile help --user-name $(terraform output -raw user_name)
Create bool variable for console_access which defaults to true.
    #vim variables.tf
    #terraform console
        #var.console_access
Create aws_iam_user_login_profile resource. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_user_login_profile
Set user as aws_iam_user.first.id and password_reset_required as true.
Set its count as 1 if var.console_access is true, else count should be 0.
    #vim iam.tf
    #terraform apply
    #terraform state show aws_iam_user_login_profile.first[0]
    #terraform show -json | jq -r '.values.root_module.resources[] | select(.address=="aws_iam_user_login_profile.first[0]") | .values.password'
    #aws iam get-login-profile --user-name $(terraform output -raw user_name)
Since password_reset_required is true, the password can only be used once.
If the user forgets the updated password and needs us to reset it,
    #terraform apply -replace 'aws_iam_user_login_profile.first[0]'
Also, the user is blocked from resetting their own password until we assign policies to do so.
Create an output block to share console_password as a sensitive value.
    #vim output.tf
    #terraform apply
    #terraform output console_password
To sign into aws console, you need account_alias or 12-digit account_id along with the user_name and password.
    #aws iam list-account-aliases
    #aws sts get-caller-identity
While the aws account may or may not have a max of one account_alias, you are guaranteed to have the 12-digit account_id.
Using aws_caller_identity data source, we can fetch account_id. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/caller_identity
    #vim iam.tf
Using aws_iam_account_alias data source, we could fetch account_alias. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/iam_account_alias
    #vim iam.tf
If account_alias doesn not exist, you can create it
    #aws iam list-account-aliases
    #aws iam create-account-alias --account-alias <globally-unique-name>
    #aws iam list-account-aliases
Lets see if the data sources are working,
    #terraform apply
    #terraform state show data.aws_caller_identity.first
    #terraform state show data.aws_iam_account_alias.first
But if account_alias doesn not exist, this working IaC will break.
    #aws iam list-account-aliases
    #aws iam delete-account-alias --account-alias $(!-1 | jq -r '.AccountAliases[0]')
    #terraform apply
    #aws iam create-account-alias --account-alias <globally-unique-name>
We do not use aws_iam_account_alias resource block, as this would create unplanned changes for users not governed by this project.
To fetch account_alias without breaking the code, lets run the aws command using the external data source
Lets add external provider to our required_providers block.
    #vim providers.tf
Disable/Comment the aws_iam_account_alias data source.
Create an external data source to run the list-account-aliases command in bash
    #aws iam list-account-aliases | jq '{alias : .AccountAliases[0]}'
    #vim iam.tf
    #terraform apply
    #terraform state show data.external.account_alias
Lets create a local that generates the signin url, by prependending signing.aws.amazon.com with account_alias and/or account_id.
coalesce function returns the first value that is not  null or empty string. https://developer.hashicorp.com/terraform/language/functions/coalesce
compact  function returns a list that does not contain null or empty string. https://developer.hashicorp.com/terraform/language/functions/compact
    #terraform console
        #coalesce(data.external.account_alias.result.alias, data.aws_caller_identity.first.id)
        #format("https://%s.signin.aws.amazon.com/console", coalesce(data.external.account_alias.result.alias, data.aws_caller_identity.first.id))
        #compact([data.external.account_alias.result.alias, data.aws_caller_identity.first.id])
        #formatlist("https://%s.signin.aws.amazon.com/console", compact([data.external.account_alias.result.alias, data.aws_caller_identity.first.id]))
    #vim iam.tf
Lets create output blocks to share these signin urls
    #vim output.tf
    #terraform apply
    #terraform output user_name
    #terraform output console_password
If you have used compact function
    #terraform output -json console_url
    #terraform output -json console_url | jq -r '.[0],.[1]'
If you have used coalesce function
    #terraform output console_url
Now try any of the console_url in the browser and test if user_name and console_password are working

iam_user authentication part is done, authorization part is next.
But before that, we must consider secure transfer of these sensitive outputs.
If we have the gpg/pgp public keys of the recipient, we can encrypt these outputs.
Check the Extras at the bottom if you need steps to create and use gpg keys.
pgp_key is an argument available on aws_iam_access_key and aws_iam_user_login_profile resources
pgp_key accpets the base64 encoding of public key. Do use the armor encoded version or the base64 encoding of the armor encoded pgp key.
Create a variable to accept encryption_key
    #vim variables.tf

--#--Uncomment backend block from providers.tf--#--

To generate aws user policies, Use https://awspolicygen.s3.amazonaws.com/policygen.html

The iam_admin user that we had create via aws console is only authorized to create IAM users and S3 buckets.
Terraform will use the iam_admin authorization to create IAM user with greater permissions.
The access of these codeified users will allow us to create and manage any resource in our aws account.
Lets create a project which we can use to manage new IAM users and their permission


||=============================================================================================
||------------Extras: Basic CRUDS of GPG keys------------
||When you want to securely share sensitive information/files with trusted people,
||you can use GnuPrivacyGuard. It is an implementation of OpenPGP standard.
||    #apt install gnupg
||
||--Create your Keys--
||All parties who will participate in this secure communication need to generate their own gpg keypairs.
||    #gpg --full-generate-key
||        ->RSA, 4096 bit, Expiry, FullName, email, Comment, Pin/Passphrase
||This generate 2 key pairs.
||The Primary/Main  public-private pair is used for signing/certifying and
||the Secondary/Sub public-private pair is used for encryption
||    #gpg --list-keys
||    #gpg --list-public-keys
||    #gpg --list-secret-keys
||If the data used to create these keys have to be corrected, the only way is to create a new set.
||To see the 8-digit(short,0xshort) or 16-digit(long,0xlong) identifier of public keys,
||    #gpg --list-keys --keyid-format <short|0xshort|long|0xlong>
||To see the full identifier/fingerprint of primary and secondary public keys,
||    #gpg --list-keys --fingerprint --fingerprint
||The data used to create the gpg key cannot be modfied but there isnt a limit on creating new keypairs.
||If you want to delete the keypairs with the intent to replace them,
||    #gpg --delete-secret-and-public-keys <key-id>
||If you ever plan on migrating to a new system, you could generate new keys.
||OR, You could export your private/secret keys from your current system.
||    #gpg --output <path/to/name.key> --armor --export-secret-keys
||Transfer it along with all your trusted public keys into your new system and import them all.
||    #gpg --import <path/to/name.key>
||After successfully importing all public-private keys to your system, wipe/delete all keys stored in your old machine.
||    #gpg --list-secret-keys --keyid-format short
||    #gpg --delete-secret-key <key-id>
||
||--Publish/Share your Public Keys--
||Now all the people who know and trust each other with share their public keys.
||    #gpg --list-public-keys --keyid-format short
||    #gpg --output <path/to/name.gpg> --export <key-id>
||    #gpg --output ~/Public/foo-pubkey.gpg --export <key-id>
||You may use either of the 2 ids, the output file will contain both public keys.
||GPG keys and operations are all in binary format. The using the --armor flag will perform a binary to ASCII encoding.
||    #gpg --output <path/to/name.asc> --armor --export <key-id>
||    #gpg --output ~/Public/foo-pubkey.asc --armor --export <key-id>
||This will allow you to share the pub keys as text or comply with any policies of not sharing or recieving binary files.
||Download the public keys of your trusted people and import it into your system
||    #gpg --import <path/to/name.gpg>
||    #gpg --import ~/Downloads/bar-pubkey.gpg
||To delete any imported public key
||    #gpg --list-keys --keyid-format short
||    #gpg --delete-key <key-id>
||Now that the public keys have be shared among all trusted parties, Lets see a basic use of Encryption and Signing
||
||----Secure transfer of Sensitive Information (Encryption)----
||Foo gets a ticket from Bar requesting onboarding to a platform. Foo creates userid and password for Bar.
||    #vim platform-creds-bar.csv
||Foo has to update the ticket with the creds in such a way that only Bar can use it.
||Foo can achieve this by encrypting the creds.csv with Bars public keys and publish the file in the ticket.
||Others can see the ticket and fetch the file, but only Bar can decrypt it and use it contents.
||Foo checks if he has public gpg keys from Bar
||    #gpg --list-keys --keyid-format short
||If not, he asks Bar to share it.
||To perform and encryption, you need the name of the <file> and the <uid> of the recipient.
||The <uid> is made up of the Full Name, Comment and email of the recipient.
||The <uid> must be passed within quotes and only needs a unique subset of it.
||Any of the below commands can encrypt a file.
||    #gpg --recipient '<uid>' --encrypt <file>
||        ->Creates file.gpg in pwd as a binary encrypted copy of file.
||    #gpg --recipient-file <person.pub> --encrypt <file>
||        ->For when you have the public key file to be used for encryption and dont intent to import the public key.
||    #gpg --armor --recipient '<uid>' --encrypt <file>
||        ->Creates file.asc in pwd as a ASCII encrypted copy of file. Allows sharing as text and passing any file scans.
||    #gpg --output <path/to/file> --armor --recipient '<uid>' --encrypt <file>
||        ->Allows for customising path, filename and extention of the encrypted file.
||Foo encrypts the platform_access-bar-creds file using Bars public key
||    #gpg --output ~/public/bar-cred.asc --armor --recipient 'bar@company' --encrypt platform-creds-bar.csv
||Foo attaches bar-creds.asc file to the ticket and informs Bar that platform access is within the file.
||Bar downloads the bar-creds.asc file from the ticket and decrypts it with their private key
||    #gpg --output ~/Documents/platform-access.csv --decrypt bar-creds.asc
||        ->If --output flag is skipped, the decrypted file would have the same name without the asc extention.
||
||----Secure Broadcast of Sensitive Information (Signing+Encryption)----
||Foo creates a detailed plan for platform maintenance and downtime.
||    #vim platform-downtime-schedule.txt
||Foo publishes this in the Alerts Dashboard which will only accept messages signed by users it trusts.
||Signed messages are created by encrypting the message file with the private key of sender.
||Any of the below commands can sign a file.
||    #gpg --sign <file>
||        ->Creates file.sig in pwd as a binary signed and encrypted copy of file.
||    #gpg --armor --sign <file>
||        ->Creates file.asc in pwd as a ASCII encrypted copy of file. Allows sharing as text and passing any file scans.
||    #gpg --output <path/to/file.asc> --armor --sign <file>
||        ->Allows for customising path, filename and extention of the signed and encrypted file.
||Foo signs and encrypts the platform-downtime-schedule file using their own private key
||    #gpg --output ~/public/platform-alert.asc --armor --sign platform-downtime-schedule.txt
||Foo uploads the platform-alert.asc file into the Alerts Dashboard.
||The Alerts Dashboard and other people who get the message can verify if the message was created by Foo and has not been tampered with.
||    #gpg --verify <signed-file>
||        ->In stdout you will see the fingerprint of the signing key, time of signing and good/bad status of the signed/encrypted file
||    #gpg --verify platform-alert.asc
||If the signature is good, we can view the contents of the message.
||    #gpg --decrypt <signed-file>
||        ->If the signed-file is good, its contents and the signature details are displayed on stdout.
||Better than viewing the file contents would be to save it.
||    #gpg --output <path/to/file> --verify <signed-file>
||    #gpg --output <path/to/file> --decrypt <signed-file>
||        ->Signature status is shared in STDOUT + save the contents of the signed-file into path/to/file
||    #gpg --output ~/Documents/alert.txt --verify platform-alert.asc
||        ->If --output flag is skipped, the decrypted contents
||
||----Broadcast of Non-Sensitive Information (Signing)----
||When you want to share information that is not sensitive but need to include that you are the author,
||    #gpg --clearsign <file>
||This will create file.asc that has your gpg signature in ASCII format appended to the bottom of the file.
||After you share the file.asc, any person who has a copy of your sign can ensure that it was signed by you with
||    #gpg --verify <clearsigned-file>
||If the non-sensitive information is code meant to be used, adding a signature to it can break the file.
||In this case you can create your signature as a seperate file, but is tied to the contents of the original file.
||In this case you can send the file and signature as seperate files.
||    #gpg --detach-sign <file>
||        ->Creates file.sig in pwd as a binary signature that is based on file contents
||    #gpg --armor --detach-sign <file>
||        ->Creates file.asc in pwd as a ASCII signature that is based on file contents
||    #gpg --output <path/to/file.asc> --armor --detach-sign <file>
||        ->Allows for customising path, filename and extention of the signature file.
||Now you have to share the the original file along with the file.asc/file.sig. People can verify it with
||    #gpg --verify <detached-signature-file> <corresponding-content-file>
||        ->Skipping the corresponding-content-file is allowed if it has the same name as that of the signature-file without the extention
||If the clearsigned file or the corresponding-content-file is modified after you have signed it,
||You will see "Bad Signature" message when performing a gpg --verify
||
