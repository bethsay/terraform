We are starting a new project of managing iam users and their permissions/policies.
    #mkdir 02-aws-iam/

So far, our terraform.tfstate had been stored locally. This is fine if you are not collaborating for your terraform projects.
Terraform allows for the use of aws s3 buckets to maintain terraform state files with encryption, versioning, file locking and access control.
The bucket must have been created and be accessible before it can be configured and as a backend.
Also, No dynamic bucket names or variable resource mapping is supported within the terraform, required_providers, backend, or provider blocks.
Knowing this lets create a sub project to handle this s3 pre-requisite.
    #mkdir ./02-aws-iam/pre-init/ && cd ./02-aws-iam/pre-init/
Use the aws provider and set it up with shared config, creds, profile. https://registry.terraform.io/providers/hashicorp/aws/latest/docs#shared-configuration-and-credentials-files
    #vim providers.tf
We wont be using s3 backend config here, so, our terraform.tfstate will be local
Initialize the project by installing the provider plugin/binary
    #terraform init
Define variables for s3_prefix(string), bucket_force_destroy(bool), bucket_extra_tags(map) with default values
    #vim variables.tf
To ensure we get a unique bucket_name, lets use a local generate a uuidv5, split it, and use any part of it as bucket suffix.
Create an aws_s3_bucket resource using the variables and local as bucket, force_destroy, and tags argument.
Terraform recomends that the backend bucket must have versioning enabled. https://developer.hashicorp.com/terraform/language/backend/s3
Create aws_s3_bucket_versioning resource with versioning Enabled for aws_s3_bucket resource. 
    #vim backend.tf
Lets output the bucket name/id to be used later.
    #vim outputs.tf
Lets get these resources created.
    #terraform apply
    #aws s3api list-buckets
    #aws s3api get-bucket-versioning --bucket $(aws s3api list-buckets | jq -r '.Buckets[0].Name')
    #terraform output s3_id
    #aws s3api get-bucket-versioning --bucket $(terraform output -raw s3_id)
Everytime you stop working on this project or when you have completed this project, delete all resources
    #terraform destroy

Lets switch back to our main project
    #cd 02-aws-iam/
Use the aws provider and set it up with shared config, creds, profile.
    #vim providers.tf
Lets configure an s3 bucket as the backend. https://developer.hashicorp.com/terraform/language/backend/s3
To run terraform commands in other project directories, use the -chdir flag
Lets re-apply our pre-init sub project.
    #terraform -chdir=./pre-init apply
    #terraform -chdir=./pre-init output s3_id
Create backed s3 block with the bucket name from pre-init, any "path/state_file_name" as key, aws region of bucket, and lockfile toggle
    #vim providers.tf
If you are not using the default s3_prefix value to create a bucket
    #terraform -chdir=./pre-init apply -var 's3_prefix=custom-name'
    #terraform -chdir=./pre-init output s3_id
    #terraform -chdir=./pre-init output -raw s3_id | { read S3_ID; sed -i "s/\(bucket *= *\"\).*\(\"\)/\1$S3_ID\2/" providers.tf
    #sed -i "s/\(bucket *= *\"\).*\(\"\)/\1$(terraform -chdir=./pre-init output -raw s3_id)\2/" providers.tf
Or if you already have a bucket created with a different name, overwrite the backend bucket value
    #sed -i "s/\(bucket *= *\"\).*\(\"\)/\1$(echo "<external_bucket_name>")\2/" providers.tf
The need to excessively use backslash makes this sed hard to read.
The LHS of sed looks for "bucket+spaces( *)+equal(=)+spaces( *)+quotes(\")+any_char(.*)+quotes(\")" to replace.
The LHS of sed also creates 2 capture groups using brackets, ie, "\(...\) and \(...\)". 1st is (bucket *= *\") and 2nd is (\").
The RHS of sed writes "1st_capture(\1)+output_of_command($(echo "name")+2nd_capture(\2)"
This sed allows the command to work if terraform fmt is run or not. It also allows you to retain any comments on the same line.
Now that provider and backend has been configured, initialize the project.
    #terraform init

If at a later time you update the backend config to a different bucket or to a different backend type, terraform init must be re-run.
If modification is to migrate the state files of current project to a different backend,
    #terraform init -force-copy
The actual flag to use is -migrate-state, but it is implied when using the flag -force-copy
If you terraform destroy your entire project and the backend bucket, and later want to init with a different backend,
Or if you use the same code/project to manage resources in a different aws account/region with a different backend.
    #terraform init -reconfigure
This will wipe the state file and disconnect the current terraform project from all resources/modules of the previous project.

Lets create the first resource of our iam project
Using the aws_iam_user resource, create a user. name is a required argument. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_user
    #vim iam.tf
path argument is optional and does not affect how the user access is utilized.
Default path value is "/". path string must always start and end with "/".
Even if the path is different from an exisiting user, the name cannot be reused.
path argument is an attribute that allows to manage policies using a tree structure of iam_users and iam_groups.
Create the resources and check if the user have been created via console or cli
    #terraform apply
    #terraform state list
    #terraform state show aws_iam_user.first
    #aws iam list-users
    #aws iam get-user help
    #aws iam list-users | jq -r '.Users[].UserName' | xargs -L 1 aws iam get-user --user-name
Lets create output blocks to retrun the id and arn of the created user. arn is amazon resource name
    #vim outputs.tf
Lets also create variables for name, path, and force_destroy to be used in aws_iam_user resource
    #vim variables.tf
    #vim iam.tf
    #terraform apply
    #terraform state output
    #aws iam get-user --user-name $(terraform output -raw user_name)
If you are taking a break from working on iam project and want to cleanup, destroy the resources here and of pre-init
    #terraform destroy -auto-approve && terraform -chdir=./pre-init destroy -auto-approve

For the user to have programmatic access, they will need to generate an access key and its corresponding secret.
    #aws iam list-access-keys --user-name $(terraform output -raw user_name)
    #aws iam create-access-key --user-name $(terraform output -raw user_name)
    #aws iam list-access-keys --user-name $(terraform output -raw user_name)
    #aws iam delete-access-key --user-name $(terraform output -raw user_name) --access-key-id $(!-1 | jq -r '.AccessKeyMetadata[].AccessKeyId')
        ->"!-1" is a history substitution. Bash will replace it with the latest command from current sessions history.
        ->This delete-access-key command will fail if list-access-keys command was not the previous command.
Create bool variable for api_access which defaults to true.
    #vim variables.tf
    #terraform console
        #var.api_access
        #var.console_access
Create aws_iam_access_key resource with the aws_iam_user.first.id. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_access_key
Set its count as 1 if var.api_access is true, else count should be 0
    #vim iam.tf
    #terraform apply
    #terraform state show aws_iam_access_key.first[0]
    #aws iam list-access-keys help
    #aws iam list-access-keys --user-name $(terraform output -raw user_name)
    #terraform show -json | jq '.values.root_module.resources[] | select(.address=="aws_iam_access_key.first[0]") | .values'
    #terraform show -json | jq '.values.root_module.resources[] | select(.address=="aws_iam_access_key.first[0]") | .values | {access_key: .id, secret_key: .secret}'
Create output block to show id of aws_iam_access_key. Use try function to set the output value of null if aws_iam_access_key doesnt exist.
To show secret of aws_iam_access_key in output block, the sensitive argument must be set to true. Use try function here as well.
    #vim output.tf
    #terraform apply
    #terraform output
    #terraform output api_access
    #terraform output api_secret
You can see that the sensitive output stays hidden after apply and output all but is shown when you specifically output it.

For the user to be able to login to aws console, We can generate a login_profile for them to use.
    #aws iam get-login-profile --user-name $(terraform output -raw user_name)
    #aws iam create-login-profile --user-name $(terraform output -raw user_name) --password <something>
        ->password must have uppercase and lowecase letters, numbers, symbols
    #aws iam get-login-profile --user-name $(terraform output -raw user_name)
    #aws iam delete-login-profile help --user-name $(terraform output -raw user_name)
Create bool variable for console_access which defaults to true.
    #vim variables.tf
    #terraform console
        #var.console_access
Create aws_iam_user_login_profile resource aws_iam_user.first.id. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_user_login_profile
Set its count as 1 if var.console_access is true, else count should be 0
    #vim iam.tf
    #terraform apply
    #terraform state show aws_iam_user_login_profile.first[0]
    #terraform show -json | jq -r '.values.root_module.resources[] | select(.address=="aws_iam_user_login_profile.first[0]") | .values.password'
    #aws iam get-login-profile --user-name $(terraform output -raw user_name)
Create an output block to share console_password as a sensitive value.
    #vim output.tf
    #terraform apply
    #terraform output console_password
To sign into aws console, you need account_alias or 12-digit account_id along with the user_name and password.
    #aws iam list-account-aliases
    #aws sts get-caller-identity
While the aws account may or may not have a max of one account_alias, you are guaranteed to have the 12-digit account_id.
Using aws_caller_identity data source, we can fetch account_id. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/caller_identity
    #vim iam.tf
Using aws_iam_account_alias data source, we could fetch account_alias. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/iam_account_alias
    #vim iam.tf
If account_alias doesn not exist, you can create it
    #aws iam list-account-aliases
    #aws iam create-account-alias --account-alias <globally-unique-name>
    #aws iam list-account-aliases
Lets see if the data sources are working,
    #terraform apply
    #terraform state show data.aws_caller_identity.first
    #terraform state show data.aws_iam_account_alias.first
But if account_alias doesn not exist, this working IaC will break.
    #aws iam list-account-aliases
    #aws iam delete-account-alias --account-alias $(!-1 | jq -r '.AccountAliases[0]')
    #terraform apply
    #aws iam create-account-alias --account-alias <globally-unique-name>
We do not use aws_iam_account_alias resource block, as this would create unexpected changes for users not governed by this project.
To fetch account_alias without breaking the code, lets run the aws command using the external data source
Lets add external provider to our required_providers block.
    #vim providers.tf
Disable/Comment the aws_iam_account_alias data source.
Create an external data source to run the list-account-aliases command in bash
    #aws iam list-account-aliases | jq '{alias : .AccountAliases[0]}'
    #vim iam.tf
    #terraform apply
    #terraform state show data.external.account_alias
Lets create a local that generates the signin url, by prependending signing.aws.amazon.com with account_alias and/or account_id.
    #terraform console
        #compact([data.external.account_alias.result.alias, data.aws_caller_identity.first.id])
        #formatlist("https://%s.signin.aws.amazon.com/console", compact([data.external.account_alias.result.alias, data.aws_caller_identity.first.id]))
    #vim iam.tf
Lets create output blocks to share these signin urls
    #vim output.tf
    #terraform apply
    #terraform output -json console_url
    #terraform output -json console_url | jq -r '.[0],.[1]'
    #terraform output console_password
    #terraform output user_name
Now try any of the console_url in the browser and test if user_name and console_password are working

--#--Uncomment backend block from providers.tf--#--

To generate aws user policies, Use https://awspolicygen.s3.amazonaws.com/policygen.html

The iam_admin user that we had create via aws console is only authorized to create IAM users and S3 buckets.
Terraform will use the iam_admin authorization to create IAM user with greater permissions.
The access of these codeified users will allow us to create and manage any resource in our aws account.
Lets create a project which we can use to manage new IAM users and their permission


