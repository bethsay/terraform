We are starting a new project of managing iam users and their permissions/policies.
    #mkdir 02-aws-iam/

So far, our terraform.tfstate had been stored locally. This is fine if you are not collaborating for your terraform projects.
Terraform allows for the use of aws s3 buckets to maintain terraform state files with encryption, versioning, file locking and access control.
The bucket must have been created and be accessible before it can be configured and as a backend.
Also, No dynamic bucket names or variable resource mapping is supported within the terraform, required_providers, backend, or provider blocks.
Knowing this lets create a sub project to handle this s3 pre-requisite.
    #mkdir ./02-aws-iam/pre-init/ && cd ./02-aws-iam/pre-init/
Use the aws provider and set it up with shared config, creds, profile. https://registry.terraform.io/providers/hashicorp/aws/latest/docs#shared-configuration-and-credentials-files
    #vim providers.tf
We wont be using s3 backend config here, so, our terraform.tfstate will be local
Initialize the project by installing the provider plugin/binary
    #terraform init
Define variables for s3_prefix(string), bucket_force_destroy(bool), bucket_extra_tags(map) with default values
    #vim variables.tf
To ensure we get a unique bucket_name, lets use a local generate a uuidv5, split it, and use any part of it as bucket suffix.
Create an aws_s3_bucket resource using the variables and local as bucket, force_destroy, and tags argument.
Terraform recomends that the backend bucket must have versioning enabled. https://developer.hashicorp.com/terraform/language/backend/s3
Create aws_s3_bucket_versioning resource with versioning Enabled for aws_s3_bucket resource. 
    #vim backend.tf
Lets output the bucket name/id to be used later.
    #vim outputs.tf
Lets get these resources created.
    #terraform apply
    #aws s3api list-buckets
    #aws s3api get-bucket-versioning --bucket $(aws s3api list-buckets | jq -r '.Buckets[0].Name')
    #terraform output s3_id
    #aws s3api get-bucket-versioning --bucket $(terraform output -raw s3_id)
Everytime you stop working on this project or when you have completed this project, delete all resources
    #terraform destroy

Lets switch back to our main project
    #cd 02-aws-iam/
Use the aws provider and set it up with shared config, creds, profile.
    #vim providers.tf
Lets configure an s3 bucket as the backend. https://developer.hashicorp.com/terraform/language/backend/s3
To run terraform commands in other project directories, use the -chdir flag
Lets re-apply our pre-init sub project.
    #terraform -chdir=./pre-init apply
    #terraform -chdir=./pre-init output s3_id
Create backed s3 block with the bucket name from pre-init, any "path/state_file_name" as key, aws region of bucket, and lockfile toggle
    #vim providers.tf
If you are not using the default s3_prefix value to create a bucket
    #terraform -chdir=./pre-init apply -var 's3_prefix=custom-name'
    #terraform -chdir=./pre-init output s3_id
    #terraform -chdir=./pre-init output -raw s3_id | { read S3_ID; sed -i "s/\(bucket *= *\"\).*\(\"\)/\1$S3_ID\2/" providers.tf
    #sed -i "s/\(bucket *= *\"\).*\(\"\)/\1$(terraform -chdir=./pre-init output -raw s3_id)\2/" providers.tf
Or if you already have a bucket created with a different name, overwrite the backend bucket value
    #sed -i "s/\(bucket *= *\"\).*\(\"\)/\1$(echo "<external_bucket_name>")\2/" providers.tf
The need to excessively use backslash makes this sed hard to read.
The LHS of sed looks for "bucket+spaces( *)+equal(=)+spaces( *)+quotes(\")+any_char(.*)+quotes(\")" to replace.
The LHS of sed also creates 2 capture groups using brackets, ie, "\(...\) and \(...\)". 1st is (bucket *= *\") and 2nd is (\").
The RHS of sed writes "1st_capture(\1)+output_of_command($(echo "name")+2nd_capture(\2)"
This sed allows the command to work if terraform fmt is run or not. It also allows you to retain any comments on the same line.
Now that provider and backend has been configured, initialize the project.
    #terraform init

If at a later time you update the backend config to a different bucket or to a different backend type, terraform init must be re-run.
If modification is to migrate the state files of current project to a different backend,
    #terraform init -force-copy
The actual flag to use is -migrate-state, but it is implied when using the flag -force-copy
If you terraform destroy your entire project and the backend bucket, and later want to init with a different backend,
Or if you use the same code/project to manage resources in a different aws account/region with a different backend.
    #terraform init -reconfigure
This will wipe the state file and disconnect the current terraform project from all resources/modules of the previous project.

While using s3 or non-local backends are important in production and environments where you are not the only user,
local backend will give faster processing of every terraform command that would reads/writes to state.
Terraform override files allow you to customise any block of your root Iac. https://developer.hashicorp.com/terraform/language/files/override
Any arguments within the blocks of the override file will replace the same argument on the original code. Other arguments of original remain as is.
You cannot create new blocks in override file. Lets override the s3 backend with a local backend.
    #vim backend_override.tf
    #terraform init -migrate-state
override files are usually gitignored in any terraform project unless you intentionally excluded it.
If you want to test the useage of s3 backend, add a .temp extention to the override file and re-run terraform init.
After testing, you revert to the tf extention and re-run terraform init -force-copy.

Lets create the first resource of our iam project
Using the aws_iam_user resource, create a user. name is a required argument. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_user
    #vim iam.tf
path argument is optional and does not affect how the user access is utilized.
Default path value is "/". path string must always start and end with "/".
Even if the path is different from an exisiting user, the name cannot be reused.
path argument is an attribute that allows to manage policies using a tree structure of iam_users and iam_groups.
Create the resources and check if the user have been created via console or cli
    #terraform apply
    #terraform state list
    #terraform state show aws_iam_user.first
    #aws iam list-users
    #aws iam get-user help
    #aws iam list-users | jq -r '.Users[].UserName' | xargs -L 1 aws iam get-user --user-name
Lets create output blocks to retrun the id and arn of the created user. arn is amazon resource name
    #vim outputs.tf
Lets also create variables for name, path, and force_destroy to be used in aws_iam_user resource
    #vim variables.tf
    #vim iam.tf
    #terraform apply
    #terraform state output
    #aws iam get-user --user-name $(terraform output -raw user_name)
If you are taking a break from working on iam project and want to cleanup, destroy the resources here and of pre-init
    #terraform destroy -auto-approve && terraform -chdir=./pre-init destroy -auto-approve

For the user to have programmatic access, they will need to generate an access key and its corresponding secret.
    #aws iam list-access-keys --user-name $(terraform output -raw user_name)
    #aws iam create-access-key --user-name $(terraform output -raw user_name)
    #aws iam list-access-keys --user-name $(terraform output -raw user_name)
    #aws iam delete-access-key --user-name $(terraform output -raw user_name) --access-key-id $(!-1 | jq -r '.AccessKeyMetadata[].AccessKeyId')
        ->"!-1" is a history substitution. Bash will replace it with the latest command from current sessions history.
        ->This delete-access-key command will fail if list-access-keys command was not the previous command.
Create bool variable for api_access which defaults to true.
    #vim variables.tf
    #terraform console
        #var.api_access
Create aws_iam_access_key resource with the aws_iam_user.first.id. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_access_key
Set its count as 1 if var.api_access is true, else count should be 0
    #vim iam.tf
    #terraform apply
    #terraform state show aws_iam_access_key.first[0]
    #aws iam list-access-keys help
    #aws iam list-access-keys --user-name $(terraform output -raw user_name)
    #terraform show -json | jq '.values.root_module.resources[] | select(.address=="aws_iam_access_key.first[0]") | .values'
    #terraform show -json | jq '.values.root_module.resources[] | select(.address=="aws_iam_access_key.first[0]") | .values | {access_key: .id, secret_key: .secret}'
Create output block to show id of aws_iam_access_key. Use one function to get the id of aws_iam_access_key if it exists.
To show secret of aws_iam_access_key in output block, the sensitive argument must be set to true. Use one function here as well.
    #vim output.tf
    #terraform apply
    #terraform output
    #terraform output api_access
    #terraform output api_secret
You can see that the sensitive output stays hidden after apply and output all but is shown when you specifically output it.

For the user to be able to login to aws console, We can generate a login_profile for them to use.
    #aws iam get-login-profile --user-name $(terraform output -raw user_name)
    #aws iam create-login-profile --user-name $(terraform output -raw user_name) --password <something>
        ->password must have uppercase and lowecase letters, numbers, symbols
    #aws iam get-login-profile --user-name $(terraform output -raw user_name)
    #aws iam delete-login-profile help --user-name $(terraform output -raw user_name)
Create bool variable for console_access which defaults to true.
    #vim variables.tf
    #terraform console
        #var.console_access
Create aws_iam_user_login_profile resource. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_user_login_profile
Set user as aws_iam_user.first.id and password_reset_required as true.
Set its count as 1 if var.console_access is true, else count should be 0.
    #vim iam.tf
    #terraform apply
    #terraform state show aws_iam_user_login_profile.first[0]
    #terraform show -json | jq -r '.values.root_module.resources[] | select(.address=="aws_iam_user_login_profile.first[0]") | .values.password'
    #aws iam get-login-profile --user-name $(terraform output -raw user_name)
Since password_reset_required is true, the password can only be used once.
If the user forgets the updated password and needs us to reset it,
    #terraform apply -replace 'aws_iam_user_login_profile.first[0]'
Also, the user is blocked from resetting their own password until we assign policies to do so.
Create an output block to share console_password as a sensitive value.
    #vim output.tf
    #terraform apply
    #terraform output console_password
Test console_password output by trying to sign-in to aws portal as IAM user
Along with user_name, you need the 12-digit account_id during sign-in.
Although password_reset_required is true, tf-user will not be able to as we have not yet authorized with a policy to do it.

To get the 12-digit account_id or account_alias you need for IAM signin,
    #aws iam list-account-aliases
    #aws sts get-caller-identity
While the aws account may or may not have a max of one account_alias, you are guaranteed to have the 12-digit account_id.
Using aws_caller_identity data source, we can fetch account_id. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/caller_identity
    #vim iam.tf
Using aws_iam_account_alias data source, we could fetch account_alias. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/iam_account_alias
    #vim iam.tf
If account_alias doesn not exist, you can create it
    #aws iam list-account-aliases
    #aws iam create-account-alias --account-alias <globally-unique-name>
    #aws iam list-account-aliases
Lets see if the data sources are working,
    #terraform apply
    #terraform state show data.aws_caller_identity.first
    #terraform state show data.aws_iam_account_alias.first
But if account_alias doesn not exist, this working IaC will break.
    #aws iam list-account-aliases
    #aws iam delete-account-alias --account-alias $(!-1 | jq -r '.AccountAliases[0]')
    #terraform apply
    #aws iam create-account-alias --account-alias <globally-unique-name>
We do not use aws_iam_account_alias resource block, as this would create unplanned changes for users not governed by this project.
To fetch account_alias without breaking the code, lets run the aws command using the external data source
Lets add external provider to our required_providers block.
    #vim providers.tf
Disable/Comment the aws_iam_account_alias data source.
Create an external data source to run the list-account-aliases command in bash
    #aws iam list-account-aliases | jq '{alias : .AccountAliases[0]}'
    #vim iam.tf
    #terraform apply
    #terraform state show data.external.account_alias
Lets create a local that generates the signin url, by prependending signing.aws.amazon.com with account_alias and/or account_id.
coalesce function returns the first value that is not  null or empty string. https://developer.hashicorp.com/terraform/language/functions/coalesce
compact  function returns a list that does not contain null or empty string. https://developer.hashicorp.com/terraform/language/functions/compact
    #terraform console
        #coalesce(data.external.account_alias.result.alias, data.aws_caller_identity.first.id)
        #format("https://%s.signin.aws.amazon.com/console", coalesce(data.external.account_alias.result.alias, data.aws_caller_identity.first.id))
        #compact([data.external.account_alias.result.alias, data.aws_caller_identity.first.id])
        #formatlist("https://%s.signin.aws.amazon.com/console", compact([data.external.account_alias.result.alias, data.aws_caller_identity.first.id]))
    #vim iam.tf
Lets create output blocks to share these signin urls
    #vim output.tf
    #terraform apply
    #terraform output user_name
    #terraform output console_password
If you have used compact function
    #terraform output -json console_url
    #terraform output -json console_url | jq -r '.[0],.[1]'
If you have used coalesce function
    #terraform output console_url
Now try any of the console_url in the browser and test if user_name and console_password are working

iam_user authentication part is done, authorization part is next.
But before that, we must consider how we securely transfer of these sensitive outputs.
If we have the gpg/pgp public keys of the recipient, we can encrypt these outputs.
Check the Extras at the bottom if you need steps to create and use gpg keys.
pgp_key is an argument available on aws_iam_access_key and aws_iam_user_login_profile resources
pgp_key accepts the base64 encoding of public key. Expect errors if you use the raw key, or the armor encoding of the key, or b64(armor(key))
Create a string variable to accept local system path to the recipients public encryption key. Set the default value as an empty string.
    #vim variables.tf
    #terraform console
        #var.encryption_key
Update aws_iam_user_login_profile and aws_iam_access_key resources with the pgp_key argument to be the result of filebase64(var.encryption_key)
filebase64 function on an empty string or file that doesnt exist will cause errors. Use try function to apply an empty string as fallback.
    #vim iam.tf
    #terraform apply -var 'encryption_key=~/Downloads/recipient_name_public.gpg'
If you dont have the public key of a recipient, you can test it with your public gpg key
    #echo 'encryption_key="~/Public/my_name-public.gpg"' > terraform.tfvars
        ->all .tfvars files are gitignored
    #terraform apply
    #terraform output
    #terraform state show aws_iam_user_login_profile.first[0]
    #terraform show -json | jq -r '.values.root_module.resources[] | select(.address=="aws_iam_access_key.first[0]") | .values'
    #terraform apply -var 'encryption_key=~/Public/my_name-public.gpg'
The attributes secret and password, which we had used as output are now null while encrypted_secret and encrypted_password attributes have values.
Create output blocks to share encrypted_secret and encrypted_password via one function.
    #vim outputs.tf
    #terraform apply
    #terraform output console_password_encrypted
These encrypted outputs can be used by the recipient after they run a base64 decode on it and then run gpg decrypt.
    #terraform output -raw api_secret_encrypted | base64 -d | gpg -d
    #terraform output -raw console_password_encrypted | base64 -d | gpg -d

Improvement task:
Create an account in https://keybase.io/ and generate pgp keys.
Use keybase:account_id as pgp_key instead of filebase64(key).
decrypt with "keybase pgp decrypt" instead of "gpg -d"

iam_user we created can be authenticated to our aws account but is not authorized to do anything.
When using the password from login_profile successfully, you would have seen a password reset page that didnt work.
This is because iam_user has not been granted authorization to change their own password.
There are about 1400+ authorization policies created and managed by AWS that are available for us to attach to any user or group.
    #aws iam list-policies | jq -r '.Policies[].PolicyName' | less -iN
Without being authorized with a policy that contains iam:ChangePassword action at the least, you cannot change your own password.
    #aws iam list-policies | jq -r '.Policies[].PolicyName' | grep -i iam
    #aws iam list-policies | jq -r '.Policies[] | select(.PolicyName|contains("IAM")) | [.PolicyName, .Arn] | @csv' | column -t -s ','
    #aws iam list-policies | jq -r '.Policies[] | select(.PolicyName|test("iam";"i")) | [.PolicyName, .Arn] | @tsv' | column -t -s $'\t'
    #aws iam list-policies | jq -r '.Policies[] | select(.PolicyName=="IAMUserChangePassword")'
IAMUserChangePassword is an exisiting policy that allows a user to change their password. Get its arn for us to paste in our Iac
    #aws iam list-policies --query 'Policies[?PolicyName==`IAMUserChangePassword`]'
    #aws iam list-policies --query 'Policies[?PolicyName==`IAMUserChangePassword`].Arn' --output text
    #aws iam get-policy --policy-arn $(!-1)
    #!-2 | xargs -I ?? aws iam get-policy --policy-arn ??
    #!-3 | xargs bash -c 'aws iam get-policy --policy-arn $1' bash
    #!-4 | xargs aws iam get-policy --policy-arn
    #!-5 | { read arn; aws iam get-policy --policy-arn $arn; }
    #aws iam list-policies --query 'Policies[?PolicyName==`IAMUserChangePassword`].DefaultVersionId' --output text
    #aws iam get-policy-version --version-id $(!-1) --policy-arn $(!-7)
    #aws iam list-policies --query 'Policies[?PolicyName==`IAMUserChangePassword`].[Arn, DefaultVersionId]' --output text
    #!-1 | xargs -d '\t' -n 2 bash -c 'aws iam get-policy-version --version-id $2 --policy-arn $1' bash
    #!-2 | xargs bash -c 'aws iam get-policy-version --version-id $2 --policy-arn $1' $0
    #!-3 | while read -r arn ver; do aws iam get-policy-version --version-id $ver --policy-arn $arn ; done
To allows the iam_user to change his password, we need to attach IAMUserChangePassword policy to tf-user
    #terraform output -raw user_name
    #aws iam list-attached-user-policies --user-name $(!-1)
    #aws iam list-policies --query 'Policies[?PolicyName==`IAMUserChangePassword`].Arn' --output text
    #aws iam attach-user-policy --user $(!-3) --policy-arn $(!-1)
    #aws iam list-attached-user-policies --user-name $(!-4)
    #aws iam detach-user-policy --user $(!-5) --policy-arn $(!-3)
    #aws iam list-attached-user-policies --user-name $(!-6)
You could have tried to reset your password in console_url via browser before we did detach-user-policy. Or wait until we attach this policy using terraform.
Create aws_iam_user_policy_attachment resource. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_user_policy_attachment
Set user as aws_iam_user.first.id and policy_arn to that of IAMUserChangePassword
    #vim iam.tf
    #terraform apply
    #aws iam list-attached-user-policies --user-name $(terraform output -raw user_name)
Now you can try to login to aws, change your password and see the aws dashboard.
    #terraform output console_url
    #terraform output user_name
    #terraform output -raw console_password_encrypted | base64 -d | gpg -d
Lets grant more authorizations to iam_user by attaching additional policy_arn.
To get the arn of the policies to attach, you could search for the policies you like and copy the arn from the below commands.
    #aws iam list-policies --query 'Policies[?PolicyName==`IAMUserChangePassword`].[PolicyName, Arn]' --output table
    #aws iam list-policies | jq -r '.Policies[] | select(.PolicyName | test("fullaccess"; "i") and test("iam|ec2|s3"; "i")) | [.PolicyName, .Arn] | @csv' | column -t -s ','
or create arn by adding the long prefix to the policy name, or fetch it from a data source.
Create a list variable to accept these managed aws_policy_names. Set the default value as an empty list/set.
Add a validation to reject AdministratorAccess policy. This is a highly risky policy to be used.
Add a validation to ensure at least IAMUserChangePassword is listed
    #vim variables.tf
    #echo 'aws_policy_names = ["IAMUserChangePassword"]' >> terraform.tfvars
    #terraform console
        #var.aws_policy_names
        #!contains(var.aws_policy_names, "AdministratorAccess")
        #contains(var.aws_policy_names, "IAMUserChangePassword") || contains(var.aws_policy_names, "IAMFullAccess")
Making the arn by adding the prefix to var.aws_policy_names is much faster, but would break if the policy is not in root path
Create aws_iam_policy data source to fetch the arns. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/iam_policy
Set the count as length(var.aws_policy_names) and set the name to cycle through the elements of var.aws_policy_names.
    #vim iam.tf
    #terraform apply
    #terraform show -json | jq -r '.values.root_module.resources[] | select(.address=="data.aws_iam_policy.first[0]") | .values'
    #terraform state show data.aws_policy_names.first[0]
Update aws_iam_user_policy_attachment.first with count as length(var.aws_policy_names),
and cycle policy_arn through data.aws_iam_policy.first[] and use the arn from each of their elements.
    #vim iam.tf
    #terraform apply
    #aws iam list-attached-user-policies --user-name $(terraform output -raw user_name)
Lets attach more policies to the iam_user.
    #sed -i "s/\(aws_policy_names *= *\[\).*\(\]\)/\1$(echo '"AmazonEC2FullAccess", "AmazonS3FullAccess", "IAMFullAccess"')\2/" terraform.tfvars
    #terraform apply
    #aws iam list-attached-user-policies --user-name $(terraform output -raw user_name)
Revert back to the minimum authorization
    #sed -i "s/\(aws_policy_names *= *\[\).*\(\]\)/\1$(echo '"IAMUserChangePassword"')\2/" terraform.tfvars
    #terraform apply
    #aws iam list-attached-user-policies --user-name $(terraform output -raw user_name)
    #sed -i '/aws_policy_names/d' terraform.tfvars
    #echo '# aws_policy_names = ["IAMUserChangePassword"]' > policies.tfvars
    #echo '# aws_policy_names = ["AmazonEC2FullAccess", "AmazonS3FullAccess", "IAMFullAccess"]' >> policies.tfvars


policies
To generate aws user policies, Use https://awspolicygen.s3.amazonaws.com/policygen.html
To validate attached policies https://policysim.aws.amazon.com/home/index.jsp
You can test the value aws specific vairables in condition blocks.
You may also use them as the expected condition values, in resource arns and principal arns
Examples of aws variables in use. https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_variables.html
List of aws global variables available. https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html
List of s3  permissions, arn, and condition variables. https://docs.aws.amazon.com/service-authorization/latest/reference/list_amazons3.html
List of iam permissions, arn, and condition variables. https://docs.aws.amazon.com/service-authorization/latest/reference/list_awsidentityandaccessmanagementiam.html
The iam_admin user that we had create via aws console is only authorized to create IAM users and S3 buckets.
Terraform will use the iam_admin authorization to create IAM user with greater permissions.
The access of these codeified users will allow us to create and manage any resource in our aws account.
Lets create a project which we can use to manage new IAM users and their permission


||=============================================================================================
||------------Extras: Basic CRUDS of GPG keys------------
||When you want to securely share sensitive information/files with trusted people,
||you can use GnuPrivacyGuard. It is an implementation of OpenPGP standard.
||    #apt install gnupg
||
||--Create your Keys--
||All parties who will participate in this secure communication need to generate their own gpg keypairs.
||    #gpg --full-generate-key
||        ->RSA, 4096 bit, Expiry, FullName, email, Comment, Pin/Passphrase
||This generate 2 key pairs.
||The Primary/Main  public-private pair is used for signing/certifying and
||the Secondary/Sub public-private pair is used for encryption
||    #gpg --list-keys
||    #gpg --list-public-keys
||    #gpg --list-secret-keys
||If the data used to create these keys have to be corrected, the only way is to create a new set.
||To see the 8-digit(short,0xshort) or 16-digit(long,0xlong) identifier of public keys,
||    #gpg --list-keys --keyid-format <short|0xshort|long|0xlong>
||To see the full identifier/fingerprint of primary and secondary public keys,
||    #gpg --list-keys --fingerprint --fingerprint
||The data used to create the gpg key cannot be modfied but there isnt a limit on creating new keypairs.
||If you want to delete the keypairs with the intent to replace them,
||    #gpg --delete-secret-and-public-keys <key-id>
||If you ever plan on migrating to a new system, you could generate new keys.
||OR, You could export your private/secret keys from your current system.
||    #gpg --output <path/to/name.key> --armor --export-secret-keys
||Transfer it along with all your trusted public keys into your new system and import them all.
||    #gpg --import <path/to/name.key>
||After successfully importing all public-private keys to your system, wipe/delete all keys stored in your old machine.
||    #gpg --list-secret-keys --keyid-format short
||    #gpg --delete-secret-key <key-id>
||
||--Publish/Share your Public Keys--
||Now all the people who know and trust each other with share their public keys.
||    #gpg --list-public-keys --keyid-format short
||    #gpg --output <path/to/name.gpg> --export <key-id>
||    #gpg --output ~/Public/foo-pubkey.gpg --export <key-id>
||You may use either of the 2 ids, the output file will contain both public keys.
||GPG keys and operations are all in binary format. The using the --armor flag will perform a binary to ASCII encoding.
||    #gpg --output <path/to/name.asc> --armor --export <key-id>
||    #gpg --output ~/Public/foo-pubkey.asc --armor --export <key-id>
||This will allow you to share the pub keys as text or comply with any policies of not sharing or recieving binary files.
||Download the public keys of your trusted people and import it into your system
||    #gpg --import <path/to/name.gpg>
||    #gpg --import ~/Downloads/bar-pubkey.gpg
||To delete any imported public key
||    #gpg --list-keys --keyid-format short
||    #gpg --delete-key <key-id>
||Now that the public keys have be shared among all trusted parties, Lets see a basic use of Encryption and Signing
||
||----Secure transfer of Sensitive Information (Encryption)----
||Foo gets a ticket from Bar requesting onboarding to a platform. Foo creates userid and password for Bar.
||    #vim platform-creds-bar.csv
||Foo has to update the ticket with the creds in such a way that only Bar can use it.
||Foo can achieve this by encrypting the creds.csv with Bars public keys and publish the file in the ticket.
||Others can see the ticket and fetch the file, but only Bar can decrypt it and use it contents.
||Foo checks if he has public gpg keys from Bar
||    #gpg --list-keys --keyid-format short
||If not, he asks Bar to share it.
||To perform and encryption, you need the name of the <file> and the <uid> of the recipient.
||The <uid> is made up of the Full Name, Comment and email of the recipient.
||The <uid> must be passed within quotes and only needs a unique subset of it.
||Any of the below commands can encrypt a file.
||    #gpg --recipient '<uid>' --encrypt <file>
||        ->Creates file.gpg in pwd as a binary encrypted copy of file.
||    #gpg --recipient-file <person.pub> --encrypt <file>
||        ->For when you have the public key file to be used for encryption and dont intent to import the public key.
||    #gpg --armor --recipient '<uid>' --encrypt <file>
||        ->Creates file.asc in pwd as a ASCII encrypted copy of file. Allows sharing as text and passing any file scans.
||    #gpg --output <path/to/file> --armor --recipient '<uid>' --encrypt <file>
||        ->Allows for customising path, filename and extention of the encrypted file.
||Foo encrypts the platform_access-bar-creds file using Bars public key
||    #gpg --output ~/public/bar-cred.asc --armor --recipient 'bar@company' --encrypt platform-creds-bar.csv
||Foo attaches bar-creds.asc file to the ticket and informs Bar that platform access is within the file.
||Bar downloads the bar-creds.asc file from the ticket and decrypts it with their private key
||    #gpg --output ~/Documents/platform-access.csv --decrypt bar-creds.asc
||        ->If --output flag is skipped, the decrypted file would have the same name without the asc extention.
||
||----Secure Broadcast of Sensitive Information (Signing+Encryption)----
||Foo creates a detailed plan for platform maintenance and downtime.
||    #vim platform-downtime-schedule.txt
||Foo publishes this in the Alerts Dashboard which will only accept messages signed by users it trusts.
||Signed messages are created by encrypting the message file with the private key of sender.
||Any of the below commands can sign a file.
||    #gpg --sign <file>
||        ->Creates file.sig in pwd as a binary signed and encrypted copy of file.
||    #gpg --armor --sign <file>
||        ->Creates file.asc in pwd as a ASCII encrypted copy of file. Allows sharing as text and passing any file scans.
||    #gpg --output <path/to/file.asc> --armor --sign <file>
||        ->Allows for customising path, filename and extention of the signed and encrypted file.
||Foo signs and encrypts the platform-downtime-schedule file using their own private key
||    #gpg --output ~/public/platform-alert.asc --armor --sign platform-downtime-schedule.txt
||Foo uploads the platform-alert.asc file into the Alerts Dashboard.
||The Alerts Dashboard and other people who get the message can verify if the message was created by Foo and has not been tampered with.
||    #gpg --verify <signed-file>
||        ->In stdout you will see the fingerprint of the signing key, time of signing and good/bad status of the signed/encrypted file
||    #gpg --verify platform-alert.asc
||If the signature is good, we can view the contents of the message.
||    #gpg --decrypt <signed-file>
||        ->If the signed-file is good, its contents and the signature details are displayed on stdout.
||Better than viewing the file contents would be to save it.
||    #gpg --output <path/to/file> --verify <signed-file>
||    #gpg --output <path/to/file> --decrypt <signed-file>
||        ->Signature status is shared in STDOUT + save the contents of the signed-file into path/to/file
||    #gpg --output ~/Documents/alert.txt --verify platform-alert.asc
||        ->If --output flag is skipped, the decrypted contents
||
||----Broadcast of Non-Sensitive Information (Signing)----
||When you want to share information that is not sensitive but need to include that you are the author,
||    #gpg --clearsign <file>
||This will create file.asc that has your gpg signature in ASCII format appended to the bottom of the file.
||After you share the file.asc, any person who has a copy of your sign can ensure that it was signed by you with
||    #gpg --verify <clearsigned-file>
||If the non-sensitive information is code meant to be used, adding a signature to it can break the file.
||In this case you can create your signature as a seperate file, but is tied to the contents of the original file.
||In this case you can send the file and signature as seperate files.
||    #gpg --detach-sign <file>
||        ->Creates file.sig in pwd as a binary signature that is based on file contents
||    #gpg --armor --detach-sign <file>
||        ->Creates file.asc in pwd as a ASCII signature that is based on file contents
||    #gpg --output <path/to/file.asc> --armor --detach-sign <file>
||        ->Allows for customising path, filename and extention of the signature file.
||Now you have to share the the original file along with the file.asc/file.sig. People can verify it with
||    #gpg --verify <detached-signature-file> <corresponding-content-file>
||        ->Skipping the corresponding-content-file is allowed if it has the same name as that of the signature-file without the extention
||If the clearsigned file or the corresponding-content-file is modified after you have signed it,
||You will see "Bad Signature" message when performing a gpg --verify
||
