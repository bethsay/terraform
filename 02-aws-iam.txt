We are starting a new project of managing iam users and their permissions/policies.
    #mkdir 02-aws-iam/

So far, our terraform.tfstate had been stored locally. This is fine if you are not collaborating for your terraform projects.
Terraform allows for the use of aws s3 buckets to maintain terraform state files with encryption, versioning, file locking and access control.
The bucket must have been created and be accessible before it can be configured and as a backend.
Also, No dynamic bucket names or variable resource mapping is supported within the terraform, required_providers, backend, or provider blocks.
Knowing this lets create a sub project to handle this s3 pre-requisite.
    #mkdir ./02-aws-iam/pre-init/ && cd ./02-aws-iam/pre-init/
Use the aws provider and set it up with shared config, creds, profile. https://registry.terraform.io/providers/hashicorp/aws/latest/docs#shared-configuration-and-credentials-files
    #vim providers.tf
We wont be using s3 backend config here, so, our terraform.tfstate will be local
Initialize the project by installing the provider plugin/binary
    #terraform init
Define variables for s3_prefix(string), bucket_force_destroy(bool), bucket_extra_tags(map) with default values
    #vim variables.tf
To ensure we get a unique bucket_name, lets use a local generate a uuidv5, split it, and use any part of it as bucket suffix.
Create an aws_s3_bucket resource using the variables and local as bucket, force_destroy, and tags argument.
Terraform recomends that the backend bucket must have versioning enabled. https://developer.hashicorp.com/terraform/language/backend/s3
Create aws_s3_bucket_versioning resource with versioning Enabled for aws_s3_bucket resource. 
    #vim backend.tf
Lets output the bucket name/id to be used later.
    #vim outputs.tf
Lets get these resources created.
    #terraform apply
    #aws s3api list-buckets
    #aws s3api get-bucket-versioning --bucket $(aws s3api list-buckets | jq -r '.Buckets[0].Name')
    #terraform output s3_id
    #aws s3api get-bucket-versioning --bucket $(terraform output -raw s3_id)
Everytime you stop working on this project or when you have completed this project, delete all resources
    #terraform destroy

Lets switch back to our main project
    #cd 02-aws-iam/
Use the aws provider and set it up with shared config, creds, profile.
    #vim providers.tf
Lets configure an s3 bucket as the backend. https://developer.hashicorp.com/terraform/language/backend/s3
To run terraform commands in other project directories, use the -chdir flag
Lets re-apply our pre-init sub project.
    #terraform -chdir=./pre-init apply
    #terraform -chdir=./pre-init output s3_id
Create backed s3 block with the bucket name from pre-init, any "path/state_file_name" as key, aws region of bucket, and lockfile toggle
    #vim providers.tf
If you are not using the default s3_prefix value to create a bucket
    #terraform -chdir=./pre-init apply -var 's3_prefix=custom-name'
    #terraform -chdir=./pre-init output s3_id
    #terraform -chdir=./pre-init output -raw s3_id | { read S3_ID; sed -i "s/\(bucket *= *\"\).*\(\"\)/\1$S3_ID\2/" providers.tf
    #sed -i "s/\(bucket *= *\"\).*\(\"\)/\1$(terraform -chdir=./pre-init output -raw s3_id)\2/" providers.tf
Or if you already have a bucket created with a different name, overwrite the backend bucket value
    #sed -i "s/\(bucket *= *\"\).*\(\"\)/\1$(echo "<external_bucket_name>")\2/" providers.tf
The need to excessively use backslash makes this sed hard to read.
The LHS of sed looks for "bucket+spaces( *)+equal(=)+spaces( *)+quotes(\")+any_char(.*)+quotes(\")" to replace.
The LHS of sed also creates 2 capture groups using brackets, ie, "\(...\) and \(...\)". 1st is (bucket *= *\") and 2nd is (\").
The RHS of sed writes "1st_capture(\1)+output_of_command($(echo "name")+2nd_capture(\2)"
This sed allows the command to work if terraform fmt is run or not. It also allows you to retain any comments on the same line.
Now that provider and backend has been configured, initialize the project.
    #terraform init

If at a later time you update the backend config to a different bucket or to a different backend type, terraform init must be re-run.
If modification is to migrate the state files of current project to a different backend,
    #terraform init -force-copy
The actual flag to use is -migrate-state, but it is implied when using the flag -force-copy
In fact, -migrate-state is implied even when you run terraform init without any flags.
You could also use the same code/project to manage resources in a different aws account/region with a different backend.
    #terraform init -reconfigure
This will wipe the state file and disconnect the current terraform project from all resources/modules of the previous project.

Lets create the first resource of our iam project
Using the aws_iam_user resource, create a user. name is a required argument. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_user
    #vim iam.tf
path argument is optional and does not affect how the user access is utilized.
path argument is an attribute that allows for tree structued policy managment of iam_user and iam_groups.

Create the resources and check if they have been created via console or cli
    #terraform apply
    #terraform state
    #aws iam list-users
    #aws iam get-user --user-name tf-user
Using aws_iam_access_key resource, create accesskey and secret. user is a required argument and should refer the name or id attribute of the aws_iam_user resource.
    #vim iam.tf
    #terraform apply
    #aws iam list-access-keys --user-name tf-user
    #terraform state show aws_iam_access_key.first
The aws_iam_access_key resource is created with its secret but is masked as it is a sensitive attribute. To see it,
    #less terraform.tfstate
    #terraform show -json | jq '.values.root_module.resources[] | select(.address=="aws_iam_access_key.first") | .values.secret'

To generate aws user policies, Use https://awspolicygen.s3.amazonaws.com/policygen.html

The iam_admin user that we had create via aws console is only authorized to create IAM users and S3 buckets.
Terraform will use the iam_admin authorization to create IAM user with greater permissions.
The access of these codeified users will allow us to create and manage any resource in our aws account.
Lets create a project which we can use to manage new IAM users and their permission


