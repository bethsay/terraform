We are starting a new project of managing iam users and their permissions/policies.
    #mkdir 02-aws-iam/

So far, our terraform.tfstate had been stored locally. This is fine if you are not collaborating for your terraform projects.
Terraform allows for the use of aws s3 buckets to maintain terraform state files with encryption, versioning, file locking and access control.
The bucket must have been created and be accessible before it can be configured and as a backend.
Also, No dynamic bucket names or variable resource mapping is supported within the terraform, required_providers, backend, or provider blocks.
Knowing this lets create a sub project to handle this s3 pre-requisite.
    #mkdir ./02-aws-iam/pre-init/ && cd ./02-aws-iam/pre-init/
Use the aws provider and set it up with shared config, creds, profile. https://registry.terraform.io/providers/hashicorp/aws/latest/docs#shared-configuration-and-credentials-files
    #vim providers.tf
We wont be using s3 backend config here, so, our terraform.tfstate will be local
Initialize the project by installing the provider plugin/binary
    #terraform init
Define variables for s3_prefix(string), bucket_force_destroy(bool), bucket_extra_tags(map) with default values
    #vim variables.tf
To ensure we get a unique bucket_name, lets use a local generate a uuidv5, split it, and use any part of it as bucket suffix.
Create an aws_s3_bucket resource using the variables and local as bucket, force_destroy, and tags argument.
Terraform recomends that the backend bucket must have versioning enabled. https://developer.hashicorp.com/terraform/language/backend/s3
Create aws_s3_bucket_versioning resource with versioning Enabled for aws_s3_bucket resource. 
    #vim backend.tf
Lets output the bucket name/id and bucket arn to be used later.
    #vim outputs.tf
Lets get these resources created.
    #terraform apply
    #aws s3api list-buckets
    #aws s3api get-bucket-versioning --bucket $(aws s3api list-buckets | jq -r '.Buckets[0].Name')
    #terraform output s3_id
    #aws s3api get-bucket-versioning --bucket $(terraform output -raw s3_id)
Everytime you stop working on this project or when you have completed this project, delete all resources
    #terraform destroy

Lets switch back to our main project
    #cd 02-aws-iam/
Use the aws provider and set it up with shared config, creds, profile.
    #vim providers.tf
Lets configure an s3 bucket as the backend. https://developer.hashicorp.com/terraform/language/backend/s3
To run terraform commands in other project directories, use the -chdir flag
Lets re-apply our pre-init sub project.
    #terraform -chdir=./pre-init apply
    #terraform -chdir=./pre-init output s3_id
Create backend s3 block with the bucket name from pre-init, any "path/state_file_name" as key, aws region of bucket, and lockfile toggle
    #vim providers.tf
If you are not using the default s3_prefix value to create a bucket
    #terraform -chdir=./pre-init apply -var 's3_prefix=custom-name'
    #terraform -chdir=./pre-init output s3_id
    #terraform -chdir=./pre-init output -raw s3_id | { read S3_ID; sed -i "s/\(bucket *= *\"\).*\(\"\)/\1$S3_ID\2/" providers.tf
    #sed -i "s/\(bucket *= *\"\).*\(\"\)/\1$(terraform -chdir=./pre-init output -raw s3_id)\2/" providers.tf
Or if you already have a bucket created with a different name, overwrite the backend bucket value
    #sed -i "s/\(bucket *= *\"\).*\(\"\)/\1$(echo "<external_bucket_name>")\2/" providers.tf
The need to excessively use backslash makes this sed hard to read.
The LHS of sed looks for "bucket+spaces( *)+equal(=)+spaces( *)+quotes(\")+any_char(.*)+quotes(\")" to replace.
The LHS of sed also creates 2 capture groups using brackets, ie, "\(...\) and \(...\)". 1st is (bucket *= *\") and 2nd is (\").
The RHS of sed writes "1st_capture(\1)+output_of_command($(echo "name")+2nd_capture(\2)"
This sed allows the command to work if terraform fmt is run or not. It also allows you to retain any comments on the same line.
Now that provider and backend has been configured, initialize the project.
    #terraform init

If at a later time you update the backend config to a different bucket or to a different backend type, terraform init must be re-run.
If modification is to migrate the state files of current project to a different backend,
    #terraform init -force-copy
The actual flag to use is -migrate-state, but it is implied when using the flag -force-copy
If you terraform destroy your entire project and the backend bucket, and later want to init with a different backend,
Or if you use the same code/project to manage resources in a different aws account/region with a different backend.
    #terraform init -reconfigure
This will wipe the state file and disconnect the current terraform project from all resources/modules of the previous project.

While using s3 or non-local backends are important in production and environments where you are not the only user,
local backend will give faster processing of every terraform command that would reads/writes to state.
Terraform override files allow you to customise any block of your root Iac. https://developer.hashicorp.com/terraform/language/files/override
Any arguments within the blocks of the override file will replace the same argument on the original code. Other arguments of original remain as is.
You cannot create new blocks in override file. Lets override the s3 backend with a local backend.
    #vim backend_override.tf
    #terraform init -migrate-state
override files are usually gitignored in any terraform project unless you intentionally excluded it.
If you want to test the useage of s3 backend, add a .temp extention to the override file and re-run terraform init.
After testing, you revert to the tf extention and re-run terraform init -force-copy.

Lets create the first resource of our iam project
Using the aws_iam_user resource, create a user. name is a required argument. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_user
    #vim iam.tf
path argument is optional and does not affect how the user access is utilized.
Default path value is "/". path string must always start and end with "/".
Even if the path is different from an existing user, the name cannot be reused.
path argument is an attribute that allows to manage policies using a tree structure of iam_users and iam_groups.
Create the resources and check if the user have been created via console or cli
    #terraform apply
    #terraform state list
    #terraform state show aws_iam_user.first
    #aws iam list-users
    #aws iam get-user help
    #aws iam list-users | jq -r '.Users[].UserName' | xargs -L 1 aws iam get-user --user-name
Lets create output blocks to retrun the id and arn of the created user. arn is amazon resource name
    #vim outputs.tf
Lets also create variables for name, path, and force_destroy to be used in aws_iam_user resource
    #vim variables.tf
    #vim iam.tf
    #terraform apply
    #terraform state output
    #aws iam get-user --user-name $(terraform output -raw user_name)
If you are taking a break from working on iam project and want to cleanup, destroy the resources here and of pre-init
    #terraform destroy -auto-approve && terraform -chdir=./pre-init destroy -auto-approve

For the user to have programmatic access, they will need to generate an access key and its corresponding secret.
    #aws iam list-access-keys --user-name $(terraform output -raw user_name)
    #aws iam create-access-key --user-name $(terraform output -raw user_name)
    #aws iam list-access-keys --user-name $(terraform output -raw user_name)
    #aws iam delete-access-key --user-name $(terraform output -raw user_name) --access-key-id $(!-1 | jq -r '.AccessKeyMetadata[].AccessKeyId')
        ->"!-1" is a history substitution. Bash will replace it with the latest command from current sessions history.
        ->This delete-access-key command will fail if list-access-keys command was not the previous command.
Create bool variable for api_access which defaults to true.
    #vim variables.tf
    #terraform console
        #var.api_access
Create aws_iam_access_key resource with the aws_iam_user.first.id. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_access_key
Set its count as 1 if var.api_access is true, else count should be 0
    #vim iam.tf
    #terraform apply
    #terraform state show aws_iam_access_key.first[0]
    #aws iam list-access-keys help
    #aws iam list-access-keys --user-name $(terraform output -raw user_name)
    #terraform show -json | jq '.values.root_module.resources[] | select(.address=="aws_iam_access_key.first[0]") | .values'
    #terraform show -json | jq '.values.root_module.resources[] | select(.address=="aws_iam_access_key.first[0]") | .values | {access_key: .id, secret_key: .secret}'
Create output block to show id of aws_iam_access_key. Use one function to get the id of aws_iam_access_key if it exists.
To show secret of aws_iam_access_key in output block, the sensitive argument must be set to true. Use one function here as well.
    #vim output.tf
    #terraform apply
    #terraform output
    #terraform output api_access
    #terraform output api_secret
You can see that the sensitive output stays hidden after apply and output all but is shown when you specifically output it.

For the user to be able to login to aws console, We can generate a login_profile for them to use.
    #aws iam get-login-profile --user-name $(terraform output -raw user_name)
    #aws iam create-login-profile --user-name $(terraform output -raw user_name) --password <something>
        ->password must have uppercase and lowecase letters, numbers, symbols
    #aws iam get-login-profile --user-name $(terraform output -raw user_name)
    #aws iam delete-login-profile help --user-name $(terraform output -raw user_name)
Create bool variable for console_access which defaults to true.
    #vim variables.tf
    #terraform console
        #var.console_access
Create aws_iam_user_login_profile resource. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_user_login_profile
Set user as aws_iam_user.first.id and password_reset_required as true.
Set its count as 1 if var.console_access is true, else count should be 0.
    #vim iam.tf
    #terraform apply
    #terraform state show aws_iam_user_login_profile.first[0]
    #terraform show -json | jq -r '.values.root_module.resources[] | select(.address=="aws_iam_user_login_profile.first[0]") | .values.password'
    #aws iam get-login-profile --user-name $(terraform output -raw user_name)
Since password_reset_required is true, the password can only be used once.
If the user forgets the updated password and needs us to reset it,
    #terraform apply -replace 'aws_iam_user_login_profile.first[0]'
Also, the user is blocked from resetting their own password until we assign policies to do so.
Create an output block to share console_password as a sensitive value.
    #vim output.tf
    #terraform apply
    #terraform output console_password
Test console_password output by trying to sign-in to aws portal as IAM user
Along with user_name, you need the 12-digit account_id during sign-in.
Although password_reset_required is true, tf-user will not be able to as we have not yet authorized with a policy to do it.

To get the 12-digit account_id or account_alias you need for IAM signin,
    #aws iam list-account-aliases
    #aws sts get-caller-identity
While the aws account may or may not have a max of one account_alias, you are guaranteed to have the 12-digit account_id.
Using aws_caller_identity data source, we can fetch account_id. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/caller_identity
    #vim iam.tf
Using aws_iam_account_alias data source, we could fetch account_alias. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/iam_account_alias
    #vim iam.tf
If account_alias doesn not exist, you can create it
    #aws iam list-account-aliases
    #aws iam create-account-alias --account-alias <globally-unique-name>
    #aws iam list-account-aliases
Lets see if the data sources are working,
    #terraform apply
    #terraform state show data.aws_caller_identity.account_id
    #terraform state show data.aws_iam_account_alias.account_alias
But if account_alias doesn not exist, this working IaC will break.
    #aws iam list-account-aliases
    #aws iam delete-account-alias --account-alias $(!-1 | jq -r '.AccountAliases[0]')
    #terraform apply
    #aws iam create-account-alias --account-alias <globally-unique-name>
We do not use aws_iam_account_alias resource block, as this would create unplanned changes for users not governed by this project.
To fetch account_alias without breaking the code, lets run the aws command using the external data source
Lets add external provider to our required_providers block.
    #vim providers.tf
Disable/Comment the aws_iam_account_alias data source.
Create an external data source to run the list-account-aliases command in bash
    #aws iam list-account-aliases | jq '{id : .AccountAliases[0]}'
    #vim iam.tf
    #terraform apply
    #terraform state show data.external.account_alias
Lets create a local that generates the signin url, by prependending signing.aws.amazon.com with account_alias and/or account_id.
coalesce function returns the first value that is not  null or empty string. https://developer.hashicorp.com/terraform/language/functions/coalesce
compact  function returns a list that does not contain null or empty string. https://developer.hashicorp.com/terraform/language/functions/compact
    #terraform console
        #coalesce(data.external.account_alias.result.id, data.aws_caller_identity.account_id.id)
        #format("https://%s.signin.aws.amazon.com/console", coalesce(data.external.account_alias.result.id, data.aws_caller_identity.account_id.id))
        #compact([data.external.account_alias.result.id, data.aws_caller_identity.account_id.id])
        #formatlist("https://%s.signin.aws.amazon.com/console", compact([data.external.account_alias.result.id, data.aws_caller_identity.account_id.id]))
    #vim iam.tf
Lets create output blocks to share these signin urls
    #vim output.tf
    #terraform apply
    #terraform output user_name
    #terraform output console_password
If you have used compact function
    #terraform output -json console_url
    #terraform output -json console_url | jq -r '.[0],.[1]'
If you have used coalesce function
    #terraform output console_url
Now try any of the console_url in the browser and test if user_name and console_password are working

iam_user authentication part is done, authorization part is next.
But before that, we must consider how we securely transfer of these sensitive outputs.
If we have the gpg/pgp public keys of the recipient, we can encrypt these outputs.
Check the Extras at the bottom if you need steps to create and use gpg keys.
pgp_key is an argument available on aws_iam_access_key and aws_iam_user_login_profile resources
pgp_key accepts the base64 encoding of public key. Expect errors if you use the raw key, or the armor encoding of the key, or b64(armor(key))
Create a string variable to accept local system path to the recipients public encryption key. Set the default value as an empty string.
    #vim variables.tf
    #terraform console
        #var.encryption_key
Update aws_iam_user_login_profile and aws_iam_access_key resources with the pgp_key argument to be the result of filebase64(var.encryption_key)
filebase64 function on an empty string or file that doesnt exist will cause errors. Use try function to apply an empty string as fallback.
    #vim iam.tf
    #terraform apply -var 'encryption_key=~/Downloads/recipient_name_public.gpg'
If you dont have the public key of a recipient, you can test it with your public gpg key
    #echo 'encryption_key="~/Public/my_name-public.gpg"' > terraform.tfvars
        ->all .tfvars files are gitignored
    #terraform apply
    #terraform output
    #terraform state show aws_iam_user_login_profile.first[0]
    #terraform show -json | jq -r '.values.root_module.resources[] | select(.address=="aws_iam_access_key.first[0]") | .values'
    #terraform apply -var 'encryption_key=~/Public/my_name-public.gpg'
The attributes secret and password, which we had used as output are now null while encrypted_secret and encrypted_password attributes have values.
Create output blocks to share encrypted_secret and encrypted_password via one function.
    #vim outputs.tf
    #terraform apply
    #terraform output console_password_encrypted
These encrypted outputs can be used by the recipient after they run a base64 decode on it and then run gpg decrypt.
    #terraform output -raw api_secret_encrypted | base64 -d | gpg -d
    #terraform output -raw console_password_encrypted | base64 -d | gpg -d

Improvement task:
Create an account in https://keybase.io/ and generate pgp keys.
Use keybase:account_id as pgp_key instead of filebase64(key).
decrypt with "keybase pgp decrypt" instead of "gpg -d"

iam_user we created can be authenticated to our aws account but is not authorized to do anything.
When using the password from login_profile successfully, you would have seen a password reset page that didnt work.
This is because iam_user has not been granted authorization to change their own password.
There are about 1400+ authorization policies created and managed by AWS that are available for us to attach to any user or group.
    #aws iam list-policies | jq -r '.Policies[].PolicyName' | less -iN
Without being authorized with a policy that contains iam:ChangePassword action at the least, you cannot change your own password.
    #aws iam list-policies | jq -r '.Policies[].PolicyName' | grep -i iam
    #aws iam list-policies | jq -r '.Policies[] | select(.PolicyName|contains("IAM")) | [.PolicyName, .Arn] | @csv' | column -t -s ','
    #aws iam list-policies | jq -r '.Policies[] | select(.PolicyName|test("iam";"i")) | [.PolicyName, .Arn] | @tsv' | column -t -s $'\t'
    #aws iam list-policies | jq -r '.Policies[] | select(.PolicyName=="IAMUserChangePassword")'
IAMUserChangePassword is an existing policy that allows a user to change their password. Get its arn for us to paste in our Iac
    #aws iam list-policies --query 'Policies[?PolicyName==`IAMUserChangePassword`]'
    #aws iam list-policies --query 'Policies[?PolicyName==`IAMUserChangePassword`].Arn' --output text
    #aws iam get-policy --policy-arn $(!-1)
    #!-2 | xargs -I ?? aws iam get-policy --policy-arn ??
    #!-3 | xargs bash -c 'aws iam get-policy --policy-arn $1' bash
    #!-4 | xargs aws iam get-policy --policy-arn
    #!-5 | { read arn; aws iam get-policy --policy-arn $arn; }
    #aws iam list-policies --query 'Policies[?PolicyName==`IAMUserChangePassword`].DefaultVersionId' --output text
    #aws iam get-policy-version --version-id $(!-1) --policy-arn $(!-7)
    #aws iam list-policies --query 'Policies[?PolicyName==`IAMUserChangePassword`].[Arn, DefaultVersionId]' --output text
    #!-1 | xargs -d '\t' -n 2 bash -c 'aws iam get-policy-version --version-id $2 --policy-arn $1' bash
    #!-2 | xargs bash -c 'aws iam get-policy-version --version-id $2 --policy-arn $1' $0
    #!-3 | while read -r arn ver; do aws iam get-policy-version --version-id $ver --policy-arn $arn ; done
To allows the iam_user to change his password, we need to attach IAMUserChangePassword policy to tf-user
    #terraform output -raw user_name
    #aws iam list-attached-user-policies --user-name $(!-1)
    #aws iam list-policies --query 'Policies[?PolicyName==`IAMUserChangePassword`].Arn' --output text
    #aws iam attach-user-policy --user $(!-3) --policy-arn $(!-1)
    #aws iam list-attached-user-policies --user-name $(!-4)
    #aws iam detach-user-policy --user $(!-5) --policy-arn $(!-3)
    #aws iam list-attached-user-policies --user-name $(!-6)
You could have successfully reset your password in console_url via browser before we did detach-user-policy. Lets wait until we attach this policy using terraform.
Create aws_iam_user_policy_attachment resource. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_user_policy_attachment
Set user as aws_iam_user.first.id and policy_arn to that of IAMUserChangePassword
    #vim iam.tf
    #terraform apply
    #aws iam list-attached-user-policies --user-name $(terraform output -raw user_name)
Now you can try to login to aws, change your password and see the aws dashboard.
    #terraform output console_url
    #terraform output user_name
    #terraform output -raw console_password_encrypted | base64 -d | gpg -d
Lets grant more authorizations to iam_user by attaching additional policy_arn.
With the below command, you could get the arn of an existing policy. But you need to know the exact policy name
    #aws iam list-policies --query 'Policies[?PolicyName==`IAMUserChangePassword`].[PolicyName, Arn]' --output table
With the below command, you could search for the names and arn of policies that exist.
    #aws iam list-policies | jq -r '.Policies[] | select(.PolicyName | test("fullaccess"; "i") and test("iam|ec2|s3"; "i")) | [.PolicyName, .Arn] | @csv' | column -t -s ','
I feel passing policy names as input variables is much prettier than passing policy arns.
Policy names can be converted to arn by either adding the long prefix to the policy name, or fetch it from a data source.
Create a list variable to accept these managed aws_policy_names. Set the default value as an empty list/set.
Add a validation to reject AdministratorAccess policy. This is a highly risky policy to be used.
Add a validation to ensure at least IAMUserChangePassword is listed
    #vim variables.tf
    #echo 'aws_policy_names = ["IAMUserChangePassword"]' > policies.tfvars
    #terraform console -var-file policies.tfvars
        #var.aws_policy_names
        #!contains(var.aws_policy_names, "AdministratorAccess")
        #contains(var.aws_policy_names, "IAMUserChangePassword") || contains(var.aws_policy_names, "IAMFullAccess")
Making the arn by adding the prefix to var.aws_policy_names is much faster, but would break if the policy is not in root path
Create aws_iam_policy data source to fetch the arns. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/iam_policy
Set the count as length(var.aws_policy_names) and set the name to cycle through the elements of var.aws_policy_names.
    #vim iam.tf
    #terraform apply -var-file policies.tfvars
    #terraform show -json | jq -r '.values.root_module.resources[] | select(.address=="data.aws_iam_policy.aws_policy[0]") | .values'
    #terraform state show data.aws_policy_names.aws_policy[0]
Update aws_iam_user_policy_attachment.aws_policy with count as length(var.aws_policy_names),
and cycle policy_arn through each data.aws_iam_policy.aws_policy and use the respective arns.
    #vim iam.tf
    #terraform apply -var-file policies.tfvars
    #aws iam list-attached-user-policies --user-name $(terraform output -raw user_name)
Lets attach more policies to the iam_user.
    #sed -i "s/\(aws_policy_names *= *\[\).*\(\]\)/\1$(echo '"AmazonEC2FullAccess", "AmazonS3FullAccess", "IAMFullAccess"')\2/" policies.tfvars
    #terraform apply -var-file policies.tfvars
    #aws iam list-attached-user-policies --user-name $(terraform output -raw user_name)
Revert back to the minimum authorization
    #sed -i "s/\(aws_policy_names *= *\[\).*\(\]\)/\1$(echo '"IAMUserChangePassword"')\2/" policies.tfvars
    #terraform apply -var-file policies.tfvars
    #aws iam list-attached-user-policies --user-name $(terraform output -raw user_name)
Lets add the list of excessive policies for future reference.
    #echo '# aws_policy_names = ["AmazonEC2FullAccess", "AmazonS3FullAccess", "IAMFullAccess"]' >> policies.tfvars

With the IAMUserChangePassword policy attached, iam_user was able to change their password once and is then redirected to the aws console homepage.
Navigate to IAM->AccessManagement->Users page. This is where you would have been able to see your user_name listed, but all see is Access Denied.
IAMUserChangePassword policy allows changing password only once, ie, when password reset is true. Too restrictive.
IAMFullAccess policy will allows altering the security scope of the entire aws account. Excessive authorization.
A policy that a proper fit for iam_user is the one you create. To generate custom policies, Use https://awspolicygen.s3.amazonaws.com/policygen.html.
Lets understand the structure of a policy document.
    #aws iam list-policies --query 'Policies[?PolicyName==`IAMUserChangePassword`].Arn' --output text
    #aws iam get-policy --policy-arn $(!-1)
    #aws iam list-policies --query 'Policies[?PolicyName==`IAMUserChangePassword`].[Arn, DefaultVersionId]' --output text
    #!-1 | xargs bash -c 'aws iam get-policy-version --version-id $2 --policy-arn $1' $0
    #!-2 | while read -r arn ver; do aws iam get-policy-version --version-id $ver --policy-arn $arn ; done
    #aws iam list-policies --query 'Policies[?PolicyName==`IAMFullAccess`].[Arn, DefaultVersionId]' --output text
    #!-1 | xargs bash -c 'aws iam get-policy-version --version-id $2 --policy-arn $1' $0
    #!-2 | while read -r arn ver; do aws iam get-policy-version --version-id $ver --policy-arn $arn ; done
The main part of the document is the list of statement blocks, ie, "Statement":[{"Effect":"","Action":[],"Resources":[]}].
In Effect, we specify "Allow" or "Deny".
In Action, we list the "aws_service:action" that policy permits or denies.
In Resources, we list the arn on which the policy actions are scoped/limited to.
Format of arn is "arn:aws:<aws_service>:<aws_region>:<account_id>:<aws_resource_type>/<path>/<aws_resource_name>"
For iam arn, aws_region is left blank. For s3 arn, aws_region and account_id are left blank.
Wildcards, ie, "*", can be used in Action list and in Resources list.
When creating an inline_policy, aim for max specificity in resources and min list of actions, to authorize know user activities only.
Full list of iam actions and its type, resource, and condition variables. https://docs.aws.amazon.com/service-authorization/latest/reference/list_awsidentityandaccessmanagementiam.html
Lets create a policy that allows iam_user user to get, read, list, view every IAM resource enabling smooth navigation within aws IAM page.
Create aws_iam_policy_document data source to generate policy statement. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/iam_policy
Within aws_iam_policy_document nest a statement block with all iam actions that start with get and list and any other read type actions.
Default statement effect is "Allow", we can skip setting it. For "Deny" statements, we must use the effect argument.
Also set a sid that identifies the statement and set resources to all within the nested statement block.
    #vim iam.tf
    #terraform apply -var-file policies.tfvars
    #terraform state show data.aws_iam_policy_document.read_all
Improve the IAMreadAll policy document by grouping the statements based on resource scope of each action.
Actions without resource scope must use resource "*" and placed in a single statement.
Actions with user scope must list the arn of users iam_user is allowed to read and be in another group.
Then create seperate statements for group, and policy resources if iam_user is allowed to read them.
Lets apply data.aws_iam_policy_document.read_all to the aws_iam_user.first
Create aws_iam_user_policy resource. https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_user_policy
Set a name for the policy, user as aws_iam_user.first.id, and policy as the json attribute of data.aws_iam_policy_document.read_all
    #vim iam.tf
    #terraform apply -var-file policies.tfvars
    #terraform output -raw user_name
    #aws iam list-user-policies --user-name $(!-1)
    #aws iam get-user-policy --user-name $(!-2) --policy-name $(!-1 --query 'PolicyNames[]' --output text)
Now IAM->AccessManagement->Users page is accesible to iam_user. You can also check out the Groups, Roles, and Policies pages.

Lets add aws_iam_policy_document data sources that allow iam_user to do more.
If we create Accesskey and secret for iam_user lets also authorize them to manage these keys and other key based auth systems.
Create aws_iam_policy_document data source with count as 1 if var.api_access is true, else be 0.
Set the statement allow all actions associated with AccessKey, SSHPublicKey, and other code based auth.
Set the resources as arn of aws_iam_user.first. Also set sid to identify this statement.
    #vim iam.tf
    #terraform apply -var-file policies.tfvars
    #terraform state show data.aws_iam_policy_document.api_security
MFA device is a unique iam resource. Once created, it can be used after enabling. Enabling includes attaching it to a user
    #aws iam list-virtual-mfa-devices
Creating and Enabling (virtual) mfa devices can be done via awscli and via terraform but is not worth the effort. Use aws console for this.
If we create console access for iam_user lets also authorize them to manage their login_profile, password and mfa
Create aws_iam_policy_document data source with count as 1 if var.console_access is true, else be 0.
Set the statement allow all actions associated with LoginProfile, MFADevice, and also ChangePassword
Set the resources as arn of aws_iam_user.first and arn of mfa with "arn:aws:iam::<account_id>:mfa/<mfa_name>"
In the mfa arn, replace account_id with id of data.caller_identity.account_id and replace mfa_name with a prifix of aws_iam_user.first.name
Also set sid to identify this statement.
    #vim iam.tf
    #terraform apply -var-file policies.tfvars
    #terraform state show data.aws_iam_policy_document.console_security
Now we have 3 aws_iam_policy_document data sources and we have only attached one of them to iam_user.
We could have created one data source block nesting all 3 statements trading-off our var.api_access and var.console_access switches.
aws_iam_policy_document data source has 2 arguments used for document merging. source_policy_documents and override_policy_documents.
Both accepts a list of json attributes from other aws_iam_policy_document data sources.
source_policy_documents pulls statements from all its list elements.
The statements of current/base aws_iam_policy_document data source are merged onto source_policy_documents statements.
override_policy_documents performs an sequential pull+merge of its elemental statements onto the merged base statements.
Statements without sid get pulled but does not participate in merging.
Statements with sid, during each merge, will have its argument values overwriten by the arguments in statements with the exact sid.
source_policy_documents cannot accept an element if its statement sid matches with the sid of another elements statement.
Create another aws_iam_policy_document with source_policy_documents as the json attribute of read_all, api_security, and console_security documents.
Use concat function to reliably handle api_security and console_security when they dont exist. concat expects read_all also as a list.
    #vim iam.tf
As we have considered iam:ChangePassword in console_security, we dont need the aws_policy IAMUserChangePassword to be attached to iam_user.
    #terraform apply
    #terraform state show data.aws_iam_policy_document.inline_policy
Update the policy in aws_iam_user_policy resource to use the json of inline_policy instead of read_all. Update the name to reflect the change.
    #vim iam.tf
    #terraform apply
    #terraform output -raw user_name
    #aws iam list-user-policies --user-name $(!-1)
    #aws iam get-user-policy --user-name $(!-2) --policy-name $(!-1 --query 'PolicyNames[]' --output text)
As iam_user, Login to aws console and create mfa device for yourself.
    #aws iam list-virtual-mfa-devices
You would have been redirected through 2 webpages to have the MFA device listed in your profile.
First page creates mfa device and the 2nd page enables it to your user.
If you had not prefixed the mfa with the name of iam_user, you would see an Access Denied when you try to go to 2nd page.
You can even try to create mfa devices for other users as well. But will not enable it for anyone else.
If you had tried this, an mfa device would have been created but not enabled.
Stale mfa devices cannot be tracked or removed via console. Same outcome would be seen if creating mfa device for yourself was interrupted.
Virtual MFA devices can be deleted only after deactivating it. Deactivating requires user_name and serial_number/arn of mfa device as arguments.
    #aws iam list-virtual-mfa-devices
    #aws iam deactivate-mfa-devices --user-name <iam_user> --serial-number <arn>
    #aws iam delete-virtual-mfa-devices --serial-number <arn>
If we had set the mfa arn without prefix, like "arn:aws:iam::*:mfa/*" in console_security,
it would require extra steps to identify who created the stale mfa device during cleanup.

We have created user inline_policy policy within the Iac, with authorization to manage their own authentication.
Lets have inline_policy be created by variables, similar to how we attached aws_policy_names.
We need the variable to accept a list(map) values. While we can have the map values can be set by the user, we must ensure map keys are fixed.
While map and objects appear the same, using type as object allows us to define the keys that variable values must use.
Use this example. https://developer.hashicorp.com/terraform/language/expressions/type-constraints#example-nested-structures-with-optional-attributes-and-defaults
Create a variable custom_policy of type list(object) that must contain sid, effect, actions, resources and conditions.
sid and effect will have string type values. actions and resources will have list(string) type values. condition will have list(object) type values.
A value of condition is an object must contain test, variable and values. test and condition will have type string while values will be list(string)
sid can be empty. Set default for effect to be "Allow", resources to be "*", condition to be [] (an empty set)
Add a validation to reject statements that has the actions "*" or "*:*". This is a highly risky policy to be used.
Set the default value of the variable to be an empty list.
    #vim variables.tf
    #terraform console
        #var.custom_policy
For nested blocks of data sources to use variables, we need to redefine them as dynamic blocks. https://developer.hashicorp.com/terraform/language/expressions/dynamic-blocks
Update data.aws_iam_policy_document.inline_policy to have a nested dynamic block that cycles for_each var.custom_policy to create statement blocks.
The content of dynamic statement block should have sid, effect, actions, and resources arguments whose values correspond to values from the var.custom_policy.
Dynamic statement block should also have a dynamic condition block that cycles for_each of the list(objects) in var.custom_policy.condition[*]
The content of dynamic condition block should have test, variable, and values arguments.
    #vim iam.tf
Alternatively you could create a data source to specifically handle var.custom_policy (if its list is not empty) and add it as a source in inline_policy.
Lets also create a custom_policy_name string variable with a default value and apply it in aws_iam_user_policy resource.
    #vim variables.tf
    #vim iam.tf
    #terraform apply

As we no longer need IAMUserChangePassword, we dont need any values for aws_policy. Comment it out.
    #vim policies.tfvars
Lets allow iam_user to Tag and Untag themselves and also to Update their user_name and path.
But using aws_iam_user.first.arn as a resource in var.custom_policy will cause errors because values of variables must be know prior to parsing of terraform code.
aws has a set of global policy variables. https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html
For aws to consider strings as policy variables they must be enclosed in ${xx}. https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_variables.html
While policy variables are meant to be used for condition testing, we may use it in the last/resource section of arn. arn:partition:service:region:account:resource
But ${xx} is also the format expected by terraform code to perform value substitution in any expression.
Due to this conflict data source aws_iam_policy_document expects aws policy variables to be enclosed by &{xx}.
Create a var.custom_policy element to allow the actions Update, Tag, and Untag on the resource user/&{aws:username}
    #vim policies.tfvars
    #terraform apply -var-file policies.tfvars
If you want to add more iam authorizations. https://docs.aws.amazon.com/service-authorization/latest/reference/list_awsidentityandaccessmanagementiam.html
aws console allows for adding and removing user tags, but updating path and name can be done only via cli.
aws has policy simulator that allows testing authorizations of any iam_user without needing to sign in as that user. https://policysim.aws.amazon.com/home/index.jsp
If you do change name, path, or tags, it will cause state drift

The pre-init sub project had created an S3 bucket to be used as terraform backend. Lets allow iam_user to do anything with that bucket.
    #terraform -chdir=./pre-init output s3_arn
Add another element to var.custom_policy. Allow all GetObject, PutObject, DeleteObject and RestoreObject actions on the any item within ${s3_arn}.
Also, allow any CreateBucket, ListBucket, GetBucket, PutBucket, DeleteBucket and LifecycleConfiguration on the resource ${s3_arn}.
Seeing the arn of a bucket, you can see that they are not scoped by account_id or region but they can be tied to both.
We know which region our backend bucket has been created in. If iam_user deletes the bucket we can limit them to recreate it in a specific region.
Add a condition to ensure aws:RequestedRegion is us-east-1. and aws:ResourceAccount (or s3:ResourceAccount) is same ${aws:PrincipalAccount}. principal=requester
    #vim policies.tfvars
    #terraform apply -var-file policies.tfvars
If the backend bucket was not create by pre-init and if it is a shared bucket in which iam_user must be limited object operations.
Add an element that has ListBucket action for path navigation and GetObject, PutObject and DeleteObject for state read+write operations.
The element must be limited to the resource arn_external_bucket, arn_external_bucket_and_backend_key and arn_external_bucket_and_backend_key.tflock
If you want to add more S3 authorizations. https://docs.aws.amazon.com/service-authorization/latest/reference/list_amazons3.html

We had run this iam project and the previous s3 project using the authorization of iam_admin.
For future project we will create iam_user and backend that is specifically scoped to the project operations.
Lets clean up
    #terraform destroy -auto-approve && terraform -chdir=./pre-init destroy -auto-approve
Thats all about 02-aws-iam project . Before we commit, lets format our code
    #terraform fmt -check
    #terraform fmt -diff

||=============================================================================================
||------------Extras: Basic CRUDS of GPG keys------------
||When you want to securely share sensitive information/files with trusted people,
||you can use GnuPrivacyGuard. It is an implementation of OpenPGP standard.
||    #apt install gnupg
||
||--Create your Keys--
||All parties who will participate in this secure communication need to generate their own gpg keypairs.
||    #gpg --full-generate-key
||        ->RSA, 4096 bit, Expiry, FullName, email, Comment, Pin/Passphrase
||This generate 2 key pairs.
||The Primary/Main  public-private pair is used for signing/certifying and
||the Secondary/Sub public-private pair is used for encryption
||    #gpg --list-keys
||    #gpg --list-public-keys
||    #gpg --list-secret-keys
||If the data used to create these keys have to be corrected, the only way is to create a new set.
||To see the 8-digit(short,0xshort) or 16-digit(long,0xlong) identifier of public keys,
||    #gpg --list-keys --keyid-format <short|0xshort|long|0xlong>
||To see the full identifier/fingerprint of primary and secondary public keys,
||    #gpg --list-keys --fingerprint --fingerprint
||The data used to create the gpg key cannot be modfied but there isnt a limit on creating new keypairs.
||If you want to delete the keypairs with the intent to replace them,
||    #gpg --delete-secret-and-public-keys <key-id>
||If you ever plan on migrating to a new system, you could generate new keys.
||OR, You could export your private/secret keys from your current system.
||    #gpg --output <path/to/name.key> --armor --export-secret-keys
||Transfer it along with all your trusted public keys into your new system and import them all.
||    #gpg --import <path/to/name.key>
||After successfully importing all public-private keys to your system, wipe/delete all keys stored in your old machine.
||    #gpg --list-secret-keys --keyid-format short
||    #gpg --delete-secret-key <key-id>
||
||--Publish/Share your Public Keys--
||Now all the people who know and trust each other with share their public keys.
||    #gpg --list-public-keys --keyid-format short
||    #gpg --output <path/to/name.gpg> --export <key-id>
||    #gpg --output ~/Public/foo-pubkey.gpg --export <key-id>
||You may use either of the 2 ids, the output file will contain both public keys.
||GPG keys and operations are all in binary format. The using the --armor flag will perform a binary to ASCII encoding.
||    #gpg --output <path/to/name.asc> --armor --export <key-id>
||    #gpg --output ~/Public/foo-pubkey.asc --armor --export <key-id>
||This will allow you to share the pub keys as text or comply with any policies of not sharing or recieving binary files.
||Download the public keys of your trusted people and import it into your system
||    #gpg --import <path/to/name.gpg>
||    #gpg --import ~/Downloads/bar-pubkey.gpg
||To delete any imported public key
||    #gpg --list-keys --keyid-format short
||    #gpg --delete-key <key-id>
||Now that the public keys have be shared among all trusted parties, Lets see a basic use of Encryption and Signing
||
||----Secure transfer of Sensitive Information (Encryption)----
||Foo gets a ticket from Bar requesting onboarding to a platform. Foo creates userid and password for Bar.
||    #vim platform-creds-bar.csv
||Foo has to update the ticket with the creds in such a way that only Bar can use it.
||Foo can achieve this by encrypting the creds.csv with Bars public keys and publish the file in the ticket.
||Others can see the ticket and fetch the file, but only Bar can decrypt it and use it contents.
||Foo checks if he has public gpg keys from Bar
||    #gpg --list-keys --keyid-format short
||If not, he asks Bar to share it.
||To perform and encryption, you need the name of the <file> and the <uid> of the recipient.
||The <uid> is made up of the Full Name, Comment and email of the recipient.
||The <uid> must be passed within quotes and only needs a unique subset of it.
||Any of the below commands can encrypt a file.
||    #gpg --recipient '<uid>' --encrypt <file>
||        ->Creates file.gpg in pwd as a binary encrypted copy of file.
||    #gpg --recipient-file <person.pub> --encrypt <file>
||        ->For when you have the public key file to be used for encryption and dont intent to import the public key.
||    #gpg --armor --recipient '<uid>' --encrypt <file>
||        ->Creates file.asc in pwd as a ASCII encrypted copy of file. Allows sharing as text and passing any file scans.
||    #gpg --output <path/to/file> --armor --recipient '<uid>' --encrypt <file>
||        ->Allows for customising path, filename and extention of the encrypted file.
||Foo encrypts the platform_access-bar-creds file using Bars public key
||    #gpg --output ~/public/bar-cred.asc --armor --recipient 'bar@company' --encrypt platform-creds-bar.csv
||Foo attaches bar-creds.asc file to the ticket and informs Bar that platform access is within the file.
||Bar downloads the bar-creds.asc file from the ticket and decrypts it with their private key
||    #gpg --output ~/Documents/platform-access.csv --decrypt bar-creds.asc
||        ->If --output flag is skipped, the decrypted file would have the same name without the asc extention.
||
||----Secure Broadcast of Sensitive Information (Signing+Encryption)----
||Foo creates a detailed plan for platform maintenance and downtime.
||    #vim platform-downtime-schedule.txt
||Foo publishes this in the Alerts Dashboard which will only accept messages signed by users it trusts.
||Signed messages are created by encrypting the message file with the private key of sender.
||Any of the below commands can sign a file.
||    #gpg --sign <file>
||        ->Creates file.sig in pwd as a binary signed and encrypted copy of file.
||    #gpg --armor --sign <file>
||        ->Creates file.asc in pwd as a ASCII encrypted copy of file. Allows sharing as text and passing any file scans.
||    #gpg --output <path/to/file.asc> --armor --sign <file>
||        ->Allows for customising path, filename and extention of the signed and encrypted file.
||Foo signs and encrypts the platform-downtime-schedule file using their own private key
||    #gpg --output ~/public/platform-alert.asc --armor --sign platform-downtime-schedule.txt
||Foo uploads the platform-alert.asc file into the Alerts Dashboard.
||The Alerts Dashboard and other people who get the message can verify if the message was created by Foo and has not been tampered with.
||    #gpg --verify <signed-file>
||        ->In stdout you will see the fingerprint of the signing key, time of signing and good/bad status of the signed/encrypted file
||    #gpg --verify platform-alert.asc
||If the signature is good, we can view the contents of the message.
||    #gpg --decrypt <signed-file>
||        ->If the signed-file is good, its contents and the signature details are displayed on stdout.
||Better than viewing the file contents would be to save it.
||    #gpg --output <path/to/file> --verify <signed-file>
||    #gpg --output <path/to/file> --decrypt <signed-file>
||        ->Signature status is shared in STDOUT + save the contents of the signed-file into path/to/file
||    #gpg --output ~/Documents/alert.txt --verify platform-alert.asc
||        ->If --output flag is skipped, the decrypted contents
||
||----Broadcast of Non-Sensitive Information (Signing)----
||When you want to share information that is not sensitive but need to include that you are the author,
||    #gpg --clearsign <file>
||This will create file.asc that has your gpg signature in ASCII format appended to the bottom of the file.
||After you share the file.asc, any person who has a copy of your sign can ensure that it was signed by you with
||    #gpg --verify <clearsigned-file>
||If the non-sensitive information is code meant to be used, adding a signature to it can break the file.
||In this case you can create your signature as a seperate file, but is tied to the contents of the original file.
||In this case you can send the file and signature as seperate files.
||    #gpg --detach-sign <file>
||        ->Creates file.sig in pwd as a binary signature that is based on file contents
||    #gpg --armor --detach-sign <file>
||        ->Creates file.asc in pwd as a ASCII signature that is based on file contents
||    #gpg --output <path/to/file.asc> --armor --detach-sign <file>
||        ->Allows for customising path, filename and extention of the signature file.
||Now you have to share the the original file along with the file.asc/file.sig. People can verify it with
||    #gpg --verify <detached-signature-file> <corresponding-content-file>
||        ->Skipping the corresponding-content-file is allowed if it has the same name as that of the signature-file without the extention
||If the clearsigned file or the corresponding-content-file is modified after you have signed it,
||You will see "Bad Signature" message when performing a gpg --verify
||
